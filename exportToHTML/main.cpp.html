<html>
<head>
<title>main.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #b3ae60;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #7a7e85;}
.s4 { color: #cf8e6d;}
.s5 { color: #bcbec4;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
main.cpp</font>
</center></td></tr></table>
<pre><span class="s0">#include </span><span class="s2">&lt;iostream&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;string&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;cctype&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;cmath&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;memory&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;unordered_map&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;vector&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;stdexcept&gt;</span>
<span class="s0">#include </span><span class="s2">&lt;fstream&gt;</span>


<span class="s3">/* 
    @brief: Fornece uma descrição breve do que a função, classe ou componente faz. 
    @param: Documenta os parâmetros de uma função, descrevendo o que cada um representa. 
    @return: Explica o valor que a função retorna. 
 */</span>

<span class="s3">/** 
 * @brief Enumeração dos tipos básicos suportados pela linguagem. 
 */</span>
<span class="s4">enum </span><span class="s1">VarType </span><span class="s5">{</span>
    <span class="s1">TYPE_INT</span><span class="s5">,</span>
    <span class="s1">TYPE_UINT</span><span class="s5">,</span>
    <span class="s1">TYPE_REAL</span><span class="s5">,</span>
    <span class="s1">TYPE_BYTE</span><span class="s5">,</span>
    <span class="s1">TYPE_STRING</span><span class="s5">,</span>
    <span class="s1">TYPE_BOOL</span><span class="s5">,</span>
    <span class="s1">TYPE_DATE_AND_TIME</span><span class="s5">,</span>
    <span class="s1">TYPE_DWORD</span><span class="s5">,</span>
    <span class="s1">TYPE_TIME</span><span class="s5">,</span>
    <span class="s3">// Arrays dos tipos básicos</span>
    <span class="s1">TYPE_ARRAY_INT</span><span class="s5">,</span>
    <span class="s1">TYPE_ARRAY_UINT</span><span class="s5">,</span>
    <span class="s1">TYPE_ARRAY_REAL</span><span class="s5">,</span>
    <span class="s1">TYPE_ARRAY_STRING</span><span class="s5">,</span>
    <span class="s1">TYPE_ARRAY_BOOL</span><span class="s5">,</span>
    <span class="s3">// Tipo desconhecido (não suportado ou indefinido)</span>
    <span class="s1">TYPE_UNKNOWN</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Enumeração dos identificadores de tokens utilizados no lexer e parser. 
 */</span>
<span class="s4">enum </span><span class="s1">TokenId </span><span class="s5">{</span>
    <span class="s1">TOK_VAR</span><span class="s5">,</span>
    <span class="s1">TOK_END_VAR</span><span class="s5">,</span>
    <span class="s1">TOK_FUNCTION</span><span class="s5">,</span>
    <span class="s1">TOK_END_FUNCTION</span><span class="s5">,</span>
    <span class="s1">TOK_OF</span><span class="s5">,</span>
    <span class="s1">TOK_PROGRAM</span><span class="s5">,</span>
    <span class="s1">TOK_END_PROGRAM</span><span class="s5">,</span>

    <span class="s3">// Estruturas de controle (condicionais)</span>
    <span class="s1">TOK_IF</span><span class="s5">,</span>
    <span class="s1">TOK_THEN</span><span class="s5">,</span>
    <span class="s1">TOK_ELSE</span><span class="s5">,</span>
    <span class="s1">TOK_END_IF</span><span class="s5">,</span>

    <span class="s3">// Tipos básicos</span>
    <span class="s1">TOK_BOOL</span><span class="s5">,</span>
    <span class="s1">TOK_INT</span><span class="s5">,</span>
    <span class="s1">TOK_UINT</span><span class="s5">,</span>
    <span class="s1">TOK_BYTE</span><span class="s5">,</span>
    <span class="s1">TOK_REAL</span><span class="s5">,</span>
    <span class="s1">TOK_STRING</span><span class="s5">,</span>
    <span class="s1">TOK_CONSTANT</span><span class="s5">,</span>
    <span class="s1">TOK_ARRAY</span><span class="s5">,</span>
    <span class="s1">TOK_STRUCT</span><span class="s5">,</span>
    <span class="s1">TOK_END_STRUCT</span><span class="s5">,</span>
    <span class="s1">TOK_DATE_AND_TIME</span><span class="s5">,</span>
    <span class="s1">TOK_TIME</span><span class="s5">,</span>

    <span class="s3">// Palavras reservadas</span>
    <span class="s1">TOK_TRUE</span><span class="s5">,</span>
    <span class="s1">TOK_FALSE</span><span class="s5">,</span>
    <span class="s1">TOK_LPAREN</span><span class="s5">,</span>
    <span class="s1">TOK_RPAREN</span><span class="s5">,</span>
    <span class="s1">TOK_LBRACKET</span><span class="s5">,</span>
    <span class="s1">TOK_RBRACKET</span><span class="s5">,</span>
    <span class="s1">TOK_IGUAL</span><span class="s5">,</span>
    <span class="s1">TOK_ATRIBUICAO</span><span class="s5">,</span>
    <span class="s1">TOK_COLON</span><span class="s5">,</span>
    <span class="s1">TOK_SEMICOLON</span><span class="s5">,</span>
    <span class="s1">TOK_COMMA</span><span class="s5">,</span>
    <span class="s1">TOK_DOT_DOT</span><span class="s5">,</span>
    <span class="s1">TOK_RETAIN</span><span class="s5">,</span>
    <span class="s1">TOK_WORD</span><span class="s5">,</span>
    <span class="s1">TOK_DWORD</span><span class="s5">,</span>

    <span class="s3">// Operadores aritméticos</span>
    <span class="s1">TOK_PLUS</span><span class="s5">,</span>
    <span class="s1">TOK_MINUS</span><span class="s5">,</span>
    <span class="s1">TOK_MULTIPLY</span><span class="s5">,</span>
    <span class="s1">TOK_DIVIDE</span><span class="s5">,</span>
    <span class="s1">TOK_MOD</span><span class="s5">,</span>

    <span class="s3">// Operadores relacionais</span>
    <span class="s1">TOK_DIFERENTE</span><span class="s5">,</span>
    <span class="s1">TOK_MAIOR</span><span class="s5">,</span>
    <span class="s1">TOK_MENOR</span><span class="s5">,</span>
    <span class="s1">TOK_MAIOR_IGUAL</span><span class="s5">,</span>
    <span class="s1">TOK_MENOR_IGUAL</span><span class="s5">,</span>

    <span class="s3">// Operadores lógicos</span>
    <span class="s1">TOK_AND</span><span class="s5">,</span>
    <span class="s1">TOK_OR</span><span class="s5">,</span>
    <span class="s1">TOK_NOT</span><span class="s5">,</span>
    <span class="s1">TOK_XOR</span><span class="s5">,</span>

    <span class="s3">// Literais numéricos e strings</span>
    <span class="s1">TOK_INT_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_UINT_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_REAL_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_STRING_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_HEX_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_OCTAL_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_BINARY_LITERAL</span><span class="s5">,</span>
    <span class="s1">TOK_IDENTIFIER</span><span class="s5">,</span>
    <span class="s1">TOK_TIME_LITERAL</span><span class="s5">,</span>

    <span class="s3">// Outros tokens especiais</span>
    <span class="s1">TOK_COMMENT</span><span class="s5">,</span>
    <span class="s1">TOK_EOF</span><span class="s5">,</span>
    <span class="s1">TOK_INVALID</span><span class="s5">,</span>
    <span class="s1">TOK_ERROR</span><span class="s5">,</span>

    <span class="s3">// Novas palavras-chave para o padrão IEC ou estrutura do programa</span>
    <span class="s1">TOK_VAR_INPUT</span><span class="s5">,</span>
    <span class="s1">TOK_END_VAR_INPUT</span><span class="s5">,</span>
    <span class="s1">TOK_VAR_OUTPUT</span><span class="s5">,</span>
    <span class="s1">TOK_END_VAR_OUTPUT</span><span class="s5">,</span>
    <span class="s1">TOK_ELSIF</span><span class="s5">,</span>
    <span class="s1">TOK_FOR</span><span class="s5">,</span>
    <span class="s1">TOK_TO</span><span class="s5">,</span>
    <span class="s1">TOK_BY</span><span class="s5">,</span>
    <span class="s1">TOK_DO</span><span class="s5">,</span>
    <span class="s1">TOK_END_FOR</span><span class="s5">,</span>
    <span class="s1">TOK_WHILE</span><span class="s5">,</span>
    <span class="s1">TOK_END_WHILE</span><span class="s5">,</span>
    <span class="s1">TOK_REPEAT</span><span class="s5">,</span>
    <span class="s1">TOK_UNTIL</span><span class="s5">,</span>
    <span class="s1">TOK_END_REPEAT</span><span class="s5">,</span>
    <span class="s1">TOK_CASE</span><span class="s5">,</span>
    <span class="s1">TOK_END_CASE</span><span class="s5">,</span>

    <span class="s3">// Suporte a tipos definidos pelo usuário (IEC)</span>
    <span class="s1">TOK_TYPE</span><span class="s5">,</span>
    <span class="s1">TOK_END_TYPE</span><span class="s5">,</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Função auxiliar para converter um TokenId em uma string descritiva. 
 * @param id TokenId a ser convertido. 
 * @return string representando o token. 
 */</span>
<span class="s1">std::string token_id_to_string</span><span class="s5">(</span><span class="s1">TokenId id</span><span class="s5">) {</span>
    <span class="s4">switch</span><span class="s5">(</span><span class="s1">id</span><span class="s5">) {</span>
        <span class="s4">case </span><span class="s1">TOK_VAR: </span><span class="s4">return </span><span class="s2">&quot;TOK_VAR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_VAR: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_VAR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_FUNCTION: </span><span class="s4">return </span><span class="s2">&quot;TOK_FUNCTION&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_FUNCTION: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_FUNCTION&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_OF: </span><span class="s4">return </span><span class="s2">&quot;TOK_OF&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_PROGRAM: </span><span class="s4">return </span><span class="s2">&quot;TOK_PROGRAM&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_PROGRAM: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_PROGRAM&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_IF: </span><span class="s4">return </span><span class="s2">&quot;TOK_IF&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_THEN: </span><span class="s4">return </span><span class="s2">&quot;TOK_THEN&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_ELSE: </span><span class="s4">return </span><span class="s2">&quot;TOK_ELSE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_IF: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_IF&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_BOOL: </span><span class="s4">return </span><span class="s2">&quot;TOK_BOOL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_INT: </span><span class="s4">return </span><span class="s2">&quot;TOK_INT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_REAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_REAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_STRING: </span><span class="s4">return </span><span class="s2">&quot;TOK_STRING&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_ARRAY: </span><span class="s4">return </span><span class="s2">&quot;TOK_ARRAY&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_STRUCT: </span><span class="s4">return </span><span class="s2">&quot;TOK_STRUCT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_STRUCT: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_STRUCT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_TRUE: </span><span class="s4">return </span><span class="s2">&quot;TOK_TRUE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_FALSE: </span><span class="s4">return </span><span class="s2">&quot;TOK_FALSE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_LPAREN: </span><span class="s4">return </span><span class="s2">&quot;TOK_LPAREN&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_RPAREN: </span><span class="s4">return </span><span class="s2">&quot;TOK_RPAREN&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_LBRACKET: </span><span class="s4">return </span><span class="s2">&quot;TOK_LBRACKET&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_RBRACKET: </span><span class="s4">return </span><span class="s2">&quot;TOK_RBRACKET&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_IGUAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_IGUAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_ATRIBUICAO: </span><span class="s4">return </span><span class="s2">&quot;TOK_ATRIBUICAO&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_COLON: </span><span class="s4">return </span><span class="s2">&quot;TOK_COLON&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_SEMICOLON: </span><span class="s4">return </span><span class="s2">&quot;TOK_SEMICOLON&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_COMMA: </span><span class="s4">return </span><span class="s2">&quot;TOK_COMMA&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_DOT_DOT: </span><span class="s4">return </span><span class="s2">&quot;TOK_DOT_DOT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_PLUS: </span><span class="s4">return </span><span class="s2">&quot;TOK_PLUS&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MINUS: </span><span class="s4">return </span><span class="s2">&quot;TOK_MINUS&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MULTIPLY: </span><span class="s4">return </span><span class="s2">&quot;TOK_MULTIPLY&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_DIVIDE: </span><span class="s4">return </span><span class="s2">&quot;TOK_DIVIDE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MOD: </span><span class="s4">return </span><span class="s2">&quot;TOK_MOD&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_DIFERENTE: </span><span class="s4">return </span><span class="s2">&quot;TOK_DIFERENTE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MAIOR: </span><span class="s4">return </span><span class="s2">&quot;TOK_MAIOR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MENOR: </span><span class="s4">return </span><span class="s2">&quot;TOK_MENOR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MAIOR_IGUAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_MAIOR_IGUAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_MENOR_IGUAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_MENOR_IGUAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_AND: </span><span class="s4">return </span><span class="s2">&quot;TOK_AND&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_OR: </span><span class="s4">return </span><span class="s2">&quot;TOK_OR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_NOT: </span><span class="s4">return </span><span class="s2">&quot;TOK_NOT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_XOR: </span><span class="s4">return </span><span class="s2">&quot;TOK_XOR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_INT_LITERAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_INT_LITERAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_REAL_LITERAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_REAL_LITERAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_STRING_LITERAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_STRING_LITERAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_HEX_LITERAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_HEX_LITERAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_OCTAL_LITERAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_OCTAL_LITERAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_BINARY_LITERAL: </span><span class="s4">return </span><span class="s2">&quot;TOK_BINARY_LITERAL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_IDENTIFIER: </span><span class="s4">return </span><span class="s2">&quot;TOK_IDENTIFIER&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_COMMENT: </span><span class="s4">return </span><span class="s2">&quot;TOK_COMMENT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_EOF: </span><span class="s4">return </span><span class="s2">&quot;TOK_EOF&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_INVALID: </span><span class="s4">return </span><span class="s2">&quot;TOK_INVALID&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_ERROR: </span><span class="s4">return </span><span class="s2">&quot;TOK_ERROR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_VAR_INPUT: </span><span class="s4">return </span><span class="s2">&quot;TOK_VAR_INPUT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_VAR_INPUT: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_VAR_INPUT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_VAR_OUTPUT: </span><span class="s4">return </span><span class="s2">&quot;TOK_VAR_OUTPUT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_VAR_OUTPUT: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_VAR_OUTPUT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_ELSIF: </span><span class="s4">return </span><span class="s2">&quot;TOK_ELSIF&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_FOR: </span><span class="s4">return </span><span class="s2">&quot;TOK_FOR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_TO: </span><span class="s4">return </span><span class="s2">&quot;TOK_TO&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_BY: </span><span class="s4">return </span><span class="s2">&quot;TOK_BY&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_DO: </span><span class="s4">return </span><span class="s2">&quot;TOK_DO&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_FOR: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_FOR&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_WHILE: </span><span class="s4">return </span><span class="s2">&quot;TOK_WHILE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_WHILE: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_WHILE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_REPEAT: </span><span class="s4">return </span><span class="s2">&quot;TOK_REPEAT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_UNTIL: </span><span class="s4">return </span><span class="s2">&quot;TOK_UNTIL&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_REPEAT: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_REPEAT&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_CASE: </span><span class="s4">return </span><span class="s2">&quot;TOK_CASE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_CASE: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_CASE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_TYPE: </span><span class="s4">return </span><span class="s2">&quot;TOK_TYPE&quot;</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_END_TYPE: </span><span class="s4">return </span><span class="s2">&quot;TOK_END_TYPE&quot;</span><span class="s5">;</span>
        <span class="s4">default</span><span class="s1">: </span><span class="s4">return </span><span class="s2">&quot;UNKNOWN_TOKEN&quot;</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Classe que representa um token identificado pelo lexer. 
 */</span>
<span class="s4">class </span><span class="s1">Token </span><span class="s5">{</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s1">TokenId id</span><span class="s5">;           </span><span class="s3">/**&lt; Identificador do tipo de token */</span>
    <span class="s1">std::string value</span><span class="s5">;    </span><span class="s3">/**&lt; Valor associado ao token (lexema) */</span>
    <span class="s4">int </span><span class="s1">line</span><span class="s5">;             </span><span class="s3">/**&lt; Linha onde o token foi encontrado */</span>
    <span class="s4">int </span><span class="s1">column</span><span class="s5">;           </span><span class="s3">/**&lt; Coluna onde o token foi encontrado */</span>

    <span class="s1">Token</span><span class="s5">() </span><span class="s1">: id</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">), </span><span class="s1">value</span><span class="s5">(</span><span class="s2">&quot;&quot;</span><span class="s5">), </span><span class="s1">line</span><span class="s5">(</span><span class="s6">0</span><span class="s5">), </span><span class="s1">column</span><span class="s5">(</span><span class="s6">0</span><span class="s5">) {}</span>
    <span class="s1">Token</span><span class="s5">(</span><span class="s1">TokenId id</span><span class="s5">, </span><span class="s1">std::string value</span><span class="s5">, </span><span class="s4">int </span><span class="s1">line</span><span class="s5">, </span><span class="s4">int </span><span class="s1">column</span><span class="s5">)</span>
        <span class="s1">: id</span><span class="s5">(</span><span class="s1">id</span><span class="s5">), </span><span class="s1">value</span><span class="s5">(</span><span class="s1">std::move</span><span class="s5">(</span><span class="s1">value</span><span class="s5">)), </span><span class="s1">line</span><span class="s5">(</span><span class="s1">line</span><span class="s5">), </span><span class="s1">column</span><span class="s5">(</span><span class="s1">column</span><span class="s5">) {}</span>

    <span class="s3">/** 
     * @brief Retorna uma string descritiva do token, útil para debug. 
     * @return Descrição do token. 
     */</span>
    <span class="s1">std::string to_string</span><span class="s5">() </span><span class="s4">const  </span><span class="s5">{</span>
        <span class="s4">return </span><span class="s2">&quot;Token(&quot; </span><span class="s5">+ </span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot;, line: &quot; </span><span class="s5">+ </span><span class="s1">std::to_string</span><span class="s5">(</span><span class="s1">line</span><span class="s5">) +</span>
               <span class="s2">&quot;, col: &quot; </span><span class="s5">+ </span><span class="s1">std::to_string</span><span class="s5">(</span><span class="s1">column</span><span class="s5">) +</span>
               <span class="s2">&quot;, id: &quot; </span><span class="s5">+ </span><span class="s1">token_id_to_string</span><span class="s5">(</span><span class="s1">id</span><span class="s5">) + </span><span class="s2">&quot;)&quot;</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Classe Lexer responsável por converter o código fonte em tokens. 
 */</span>
<span class="s4">class </span><span class="s1">Lexer </span><span class="s5">{</span>
<span class="s4">private</span><span class="s1">:</span>
    <span class="s1">std::string input</span><span class="s5">;     </span><span class="s3">/**&lt; Código fonte completo */</span>
    <span class="s1">size_t pos </span><span class="s5">= </span><span class="s6">0</span><span class="s5">;        </span><span class="s3">/**&lt; Posição atual no input */</span>
    <span class="s4">int </span><span class="s1">current_line </span><span class="s5">= </span><span class="s6">1</span><span class="s5">;  </span><span class="s3">/**&lt; Linha atual no código fonte */</span>
    <span class="s4">int </span><span class="s1">current_column </span><span class="s5">= </span><span class="s6">1</span><span class="s5">;</span><span class="s3">/**&lt; Coluna atual no código fonte */</span>

    <span class="s3">/** 
     * @brief Retorna o caractere atual ou '\0' se atingiu o fim do input. 
     */</span>
    <span class="s4">char </span><span class="s1">peek</span><span class="s5">() </span><span class="s4">const </span><span class="s5">{</span>
        <span class="s4">return </span><span class="s5">(</span><span class="s1">pos </span><span class="s5">&lt; </span><span class="s1">input</span><span class="s5">.</span><span class="s1">size</span><span class="s5">()) </span><span class="s1">? input</span><span class="s5">[</span><span class="s1">pos</span><span class="s5">] </span><span class="s1">: </span><span class="s2">'</span><span class="s4">\0</span><span class="s2">'</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Avança um caractere no input e atualiza os contadores de linha/coluna. 
     * @return Caractere avançado. 
     */</span>
    <span class="s4">char </span><span class="s1">advance</span><span class="s5">() {</span>
        <span class="s4">char </span><span class="s1">c </span><span class="s5">= </span><span class="s1">peek</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">!= </span><span class="s2">'</span><span class="s4">\0</span><span class="s2">'</span><span class="s5">) {</span>
            <span class="s1">pos</span><span class="s5">++;</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'</span><span class="s4">\n</span><span class="s2">'</span><span class="s5">) {</span>
                <span class="s1">current_line</span><span class="s5">++;</span>
                <span class="s1">current_column </span><span class="s5">= </span><span class="s6">1</span><span class="s5">;</span>
            <span class="s5">}</span>
            <span class="s4">else if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'</span><span class="s4">\t</span><span class="s2">'</span><span class="s5">) {</span>
                <span class="s1">current_column </span><span class="s5">+= </span><span class="s6">4</span><span class="s5">;  </span><span class="s3">// Considera tabulação de 4 espaços</span>
            <span class="s5">}</span>
            <span class="s4">else </span><span class="s5">{</span>
                <span class="s1">current_column</span><span class="s5">++;</span>
            <span class="s5">}</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">c</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Ignora espaços em branco (whitespaces) no código fonte. 
     */</span>
    <span class="s4">void </span><span class="s1">skip_whitespace</span><span class="s5">() {</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">std::isspace</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">peek</span><span class="s5">())) {</span>
            <span class="s1">advance</span><span class="s5">();</span>
        <span class="s5">}</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Pula um comentário delimitado por &quot;(*&quot; e &quot;*)&quot; no código fonte. 
     */</span>
    <span class="s4">void </span><span class="s1">skip_comment</span><span class="s5">() {</span>
        <span class="s3">/** 
         * Já identificamos os caracteres '(' e '*'. 
         * Avança dois caracteres para consumir &quot;(*&quot;. 
         */</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome '('</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome '*'</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s4">true</span><span class="s5">) {</span>
            <span class="s4">char </span><span class="s1">c </span><span class="s5">= </span><span class="s1">peek</span><span class="s5">();</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'</span><span class="s4">\0</span><span class="s2">'</span><span class="s5">) {</span>
                <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Unterminated comment on line &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">current_line </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
                <span class="s4">return</span><span class="s5">;</span>
            <span class="s5">}</span>
            <span class="s3">// Se encontrar '*' seguido de ')', encerra o comentário</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'*' </span><span class="s5">&amp;&amp; (</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1 </span><span class="s5">&lt; </span><span class="s1">input</span><span class="s5">.</span><span class="s1">size</span><span class="s5">()) &amp;&amp; </span><span class="s1">input</span><span class="s5">[</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1</span><span class="s5">] == </span><span class="s2">')'</span><span class="s5">) {</span>
                <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome '*'</span>
                <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome ')'</span>
                <span class="s4">break</span><span class="s5">;</span>
            <span class="s5">}</span>
            <span class="s1">advance</span><span class="s5">();</span>
        <span class="s5">}</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Lê um identificador, que deve iniciar com letra ou '_' seguido de letras, dígitos ou '_'. 
     * @return String com o identificador. 
     */</span>
    <span class="s1">std::string parse_identifier</span><span class="s5">() {</span>
        <span class="s1">std::string ident</span><span class="s5">;</span>
        <span class="s4">char </span><span class="s1">first </span><span class="s5">= </span><span class="s1">peek</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(!(</span><span class="s1">std::isalpha</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">first</span><span class="s5">) || </span><span class="s1">first </span><span class="s5">== </span><span class="s2">'_'</span><span class="s5">)) {</span>
            <span class="s4">return </span><span class="s2">&quot;&quot;</span><span class="s5">;</span>
        <span class="s5">}</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">std::isalnum</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">peek</span><span class="s5">()) || </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'_'</span><span class="s5">) {</span>
            <span class="s1">ident</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">ident</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Classifica uma string identificada como palavra-chave ou como um identificador comum. 
     * @param ident String lida. 
     * @return TokenId correspondente. 
     */</span>
    <span class="s1">TokenId classify_keyword</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">ident</span><span class="s5">) {</span>
        <span class="s4">static const </span><span class="s1">std::unordered_map</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">, </span><span class="s1">TokenId</span><span class="s5">&gt; </span><span class="s1">keywords </span><span class="s5">= {</span>
            <span class="s5">{</span><span class="s2">&quot;VAR&quot;</span><span class="s5">, </span><span class="s1">TOK_VAR</span><span class="s5">}, {</span><span class="s2">&quot;END_VAR&quot;</span><span class="s5">, </span><span class="s1">TOK_END_VAR</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;IF&quot;</span><span class="s5">, </span><span class="s1">TOK_IF</span><span class="s5">}, {</span><span class="s2">&quot;THEN&quot;</span><span class="s5">, </span><span class="s1">TOK_THEN</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;ELSE&quot;</span><span class="s5">, </span><span class="s1">TOK_ELSE</span><span class="s5">}, {</span><span class="s2">&quot;END_IF&quot;</span><span class="s5">, </span><span class="s1">TOK_END_IF</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;BOOL&quot;</span><span class="s5">, </span><span class="s1">TOK_BOOL</span><span class="s5">}, {</span><span class="s2">&quot;INT&quot;</span><span class="s5">, </span><span class="s1">TOK_INT</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;REAL&quot;</span><span class="s5">, </span><span class="s1">TOK_REAL</span><span class="s5">}, {</span><span class="s2">&quot;STRING&quot;</span><span class="s5">, </span><span class="s1">TOK_STRING</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;ARRAY&quot;</span><span class="s5">, </span><span class="s1">TOK_ARRAY</span><span class="s5">}, {</span><span class="s2">&quot;STRUCT&quot;</span><span class="s5">, </span><span class="s1">TOK_STRUCT</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;AND&quot;</span><span class="s5">, </span><span class="s1">TOK_AND</span><span class="s5">}, {</span><span class="s2">&quot;OR&quot;</span><span class="s5">, </span><span class="s1">TOK_OR</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;NOT&quot;</span><span class="s5">, </span><span class="s1">TOK_NOT</span><span class="s5">}, {</span><span class="s2">&quot;XOR&quot;</span><span class="s5">, </span><span class="s1">TOK_XOR</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;FUNCTION&quot;</span><span class="s5">, </span><span class="s1">TOK_FUNCTION</span><span class="s5">}, {</span><span class="s2">&quot;END_FUNCTION&quot;</span><span class="s5">, </span><span class="s1">TOK_END_FUNCTION</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;OF&quot;</span><span class="s5">, </span><span class="s1">TOK_OF</span><span class="s5">}, {</span><span class="s2">&quot;MOD&quot;</span><span class="s5">, </span><span class="s1">TOK_MOD</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;PROGRAM&quot;</span><span class="s5">, </span><span class="s1">TOK_PROGRAM</span><span class="s5">}, {</span><span class="s2">&quot;END_PROGRAM&quot;</span><span class="s5">, </span><span class="s1">TOK_END_PROGRAM</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;TRUE&quot;</span><span class="s5">, </span><span class="s1">TOK_TRUE</span><span class="s5">}, {</span><span class="s2">&quot;FALSE&quot;</span><span class="s5">, </span><span class="s1">TOK_FALSE</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;END_STRUCT&quot;</span><span class="s5">, </span><span class="s1">TOK_END_STRUCT</span><span class="s5">}, {</span><span class="s2">&quot;VAR_INPUT&quot;</span><span class="s5">, </span><span class="s1">TOK_VAR_INPUT</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;END_VAR_INPUT&quot;</span><span class="s5">, </span><span class="s1">TOK_END_VAR_INPUT</span><span class="s5">}, {</span><span class="s2">&quot;VAR_OUTPUT&quot;</span><span class="s5">, </span><span class="s1">TOK_VAR_OUTPUT</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;END_VAR_OUTPUT&quot;</span><span class="s5">, </span><span class="s1">TOK_END_VAR_OUTPUT</span><span class="s5">}, {</span><span class="s2">&quot;ELSIF&quot;</span><span class="s5">, </span><span class="s1">TOK_ELSIF</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;FOR&quot;</span><span class="s5">, </span><span class="s1">TOK_FOR</span><span class="s5">}, {</span><span class="s2">&quot;TO&quot;</span><span class="s5">, </span><span class="s1">TOK_TO</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;BY&quot;</span><span class="s5">, </span><span class="s1">TOK_BY</span><span class="s5">}, {</span><span class="s2">&quot;DO&quot;</span><span class="s5">, </span><span class="s1">TOK_DO</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;END_FOR&quot;</span><span class="s5">, </span><span class="s1">TOK_END_FOR</span><span class="s5">}, {</span><span class="s2">&quot;WHILE&quot;</span><span class="s5">, </span><span class="s1">TOK_WHILE</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;END_WHILE&quot;</span><span class="s5">, </span><span class="s1">TOK_END_WHILE</span><span class="s5">}, {</span><span class="s2">&quot;REPEAT&quot;</span><span class="s5">, </span><span class="s1">TOK_REPEAT</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;UNTIL&quot;</span><span class="s5">, </span><span class="s1">TOK_UNTIL</span><span class="s5">}, {</span><span class="s2">&quot;END_REPEAT&quot;</span><span class="s5">, </span><span class="s1">TOK_END_REPEAT</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;CASE&quot;</span><span class="s5">, </span><span class="s1">TOK_CASE</span><span class="s5">}, {</span><span class="s2">&quot;END_CASE&quot;</span><span class="s5">, </span><span class="s1">TOK_END_CASE</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;TYPE&quot;</span><span class="s5">, </span><span class="s1">TOK_TYPE</span><span class="s5">}, {</span><span class="s2">&quot;END_TYPE&quot;</span><span class="s5">, </span><span class="s1">TOK_END_TYPE</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;RETAIN&quot;</span><span class="s5">, </span><span class="s1">TOK_RETAIN</span><span class="s5">}, {</span><span class="s2">&quot;WORD&quot;</span><span class="s5">, </span><span class="s1">TOK_WORD</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;DWORD&quot;</span><span class="s5">, </span><span class="s1">TOK_DWORD</span><span class="s5">}, {</span><span class="s2">&quot;BYTE&quot;</span><span class="s5">, </span><span class="s1">TOK_BYTE</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;CONSTANT&quot; </span><span class="s5">,</span><span class="s1">TOK_CONSTANT</span><span class="s5">}, {</span><span class="s2">&quot;DATE_AND_TIME&quot;</span><span class="s5">, </span><span class="s1">TOK_DATE_AND_TIME</span><span class="s5">},</span>
            <span class="s5">{</span><span class="s2">&quot;UINT&quot;</span><span class="s5">, </span><span class="s1">TOK_UINT</span><span class="s5">}, {</span><span class="s2">&quot;TIME&quot;</span><span class="s5">, </span><span class="s1">TOK_TIME</span><span class="s5">},</span>
        <span class="s5">};</span>
        <span class="s4">auto </span><span class="s1">it </span><span class="s5">= </span><span class="s1">keywords</span><span class="s5">.</span><span class="s1">find</span><span class="s5">(</span><span class="s1">ident</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s5">(</span><span class="s1">it </span><span class="s5">!= </span><span class="s1">keywords</span><span class="s5">.</span><span class="s1">end</span><span class="s5">()) </span><span class="s1">? it</span><span class="s5">-&gt;</span><span class="s1">second : TOK_IDENTIFIER</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Parseia um número, suportando sinais, bases numéricas (hex, octal, binário) e números reais. 
     * @return Token contendo o literal numérico. 
     */</span>
    <span class="s1">Token parse_number</span><span class="s5">() {</span>
        <span class="s4">int </span><span class="s1">start_line </span><span class="s5">= </span><span class="s1">current_line</span><span class="s5">;</span>
        <span class="s4">int </span><span class="s1">start_col  </span><span class="s5">= </span><span class="s1">current_column</span><span class="s5">;</span>

        <span class="s3">// 1) Verifica sinal opcional</span>
        <span class="s4">bool </span><span class="s1">negative </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
        <span class="s4">bool </span><span class="s1">positive </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'-' </span><span class="s5">|| </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'+'</span><span class="s5">) {</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'-'</span><span class="s5">) </span><span class="s1">negative </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
            <span class="s4">else </span><span class="s1">positive </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
        <span class="s5">}</span>

        <span class="s1">std::string num</span><span class="s5">;</span>
        <span class="s4">bool </span><span class="s1">is_real </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
        <span class="s4">bool </span><span class="s1">is_hex </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
        <span class="s4">bool </span><span class="s1">is_oct </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
        <span class="s4">bool </span><span class="s1">is_bin </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>

        <span class="s3">/** 
         * @brief Lê os dígitos e verifica se há especificação de base (ex.: 16#FF). 
         */</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">std::isdigit</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">peek</span><span class="s5">()) || </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'.' </span><span class="s5">|| </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'#'</span><span class="s5">) {</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'.'</span><span class="s5">) {</span>
                <span class="s3">// Se já tiver ponto, encerra para evitar múltiplos pontos</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">is_real</span><span class="s5">) </span><span class="s4">break</span><span class="s5">;</span>
                <span class="s3">// Se for &quot;..&quot;, também encerra</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1 </span><span class="s5">&lt; </span><span class="s1">input</span><span class="s5">.</span><span class="s1">size</span><span class="s5">() &amp;&amp; </span><span class="s1">input</span><span class="s5">[</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1</span><span class="s5">] == </span><span class="s2">'.'</span><span class="s5">) {</span>
                    <span class="s4">break</span><span class="s5">;</span>
                <span class="s5">}</span>
                <span class="s1">is_real </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
                <span class="s1">num</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
            <span class="s5">}</span>
            <span class="s4">else if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'#'</span><span class="s5">) {</span>
                <span class="s3">// Exemplo: &quot;16#&quot;</span>
                <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome '#'</span>

                <span class="s4">if </span><span class="s5">(</span><span class="s1">num </span><span class="s5">== </span><span class="s2">&quot;16&quot;</span><span class="s5">) {</span>
                    <span class="s1">num</span><span class="s5">.</span><span class="s1">clear</span><span class="s5">();</span>
                    <span class="s1">is_hex </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
                <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">num </span><span class="s5">== </span><span class="s2">&quot;8&quot;</span><span class="s5">) {</span>
                    <span class="s1">num</span><span class="s5">.</span><span class="s1">clear</span><span class="s5">();</span>
                    <span class="s1">is_oct </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
                <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">num </span><span class="s5">== </span><span class="s2">&quot;2&quot;</span><span class="s5">) {</span>
                    <span class="s1">num</span><span class="s5">.</span><span class="s1">clear</span><span class="s5">();</span>
                    <span class="s1">is_bin </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
                <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
                    <span class="s1">std::string msg </span><span class="s5">= </span><span class="s2">&quot;Base inválida: &quot; </span><span class="s5">+ </span><span class="s1">num</span><span class="s5">;</span>
                    <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_ERROR</span><span class="s5">, </span><span class="s1">msg</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s3">// Interrompe o loop para ler o valor na base especificada</span>
                <span class="s4">break</span><span class="s5">;</span>
            <span class="s5">}</span>
            <span class="s4">else </span><span class="s5">{</span>
                <span class="s3">// Lê o dígito</span>
                <span class="s1">num</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
            <span class="s5">}</span>
        <span class="s5">}</span>

        <span class="s3">// Caso de número hexadecimal</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">is_hex</span><span class="s5">) {</span>
            <span class="s3">// Lê dígitos hexadecimais (0-9, A-F, a-f) e ignora underscores</span>
            <span class="s4">while </span><span class="s5">(</span><span class="s1">std::isxdigit</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">peek</span><span class="s5">()) || </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'_'</span><span class="s5">) {</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'_'</span><span class="s5">) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                    <span class="s4">continue</span><span class="s5">;</span>
                <span class="s5">}</span>
                <span class="s1">num</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">()) {</span>
                <span class="s1">std::string msg </span><span class="s5">= </span><span class="s2">&quot;Número hexadecimal inválido (nenhum dígito após #)&quot;</span><span class="s5">;</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_ERROR</span><span class="s5">, </span><span class="s1">msg</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">negative</span><span class="s5">) {</span>
                <span class="s1">num</span><span class="s5">.</span><span class="s1">insert</span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">begin</span><span class="s5">(), </span><span class="s2">'-'</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_HEX_LITERAL</span><span class="s5">, </span><span class="s1">num</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">is_oct</span><span class="s5">) {</span>
            <span class="s3">// Lê dígitos octais (0-7)</span>
            <span class="s4">while </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() &gt;= </span><span class="s2">'0' </span><span class="s5">&amp;&amp; </span><span class="s1">peek</span><span class="s5">() &lt;= </span><span class="s2">'7' </span><span class="s5">|| </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'_'</span><span class="s5">) {</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'_'</span><span class="s5">) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                    <span class="s4">continue</span><span class="s5">;</span>
                <span class="s5">}</span>
                <span class="s1">num</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">()) {</span>
                <span class="s1">std::string msg </span><span class="s5">= </span><span class="s2">&quot;Número octal inválido (nenhum dígito após #)&quot;</span><span class="s5">;</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_ERROR</span><span class="s5">, </span><span class="s1">msg</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">negative</span><span class="s5">) </span><span class="s1">num</span><span class="s5">.</span><span class="s1">insert</span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">begin</span><span class="s5">(), </span><span class="s2">'-'</span><span class="s5">);</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_OCTAL_LITERAL</span><span class="s5">, </span><span class="s1">num</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">is_bin</span><span class="s5">) {</span>
            <span class="s3">// Lê dígitos binários (0 ou 1)</span>
            <span class="s4">while </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'0' </span><span class="s5">|| </span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'1'</span><span class="s5">) {</span>
                <span class="s1">num</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">()) {</span>
                <span class="s1">std::string msg </span><span class="s5">= </span><span class="s2">&quot;Número binario inválido (nenhum dígito após #)&quot;</span><span class="s5">;</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_ERROR</span><span class="s5">, </span><span class="s1">msg</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">negative</span><span class="s5">) </span><span class="s1">num</span><span class="s5">.</span><span class="s1">insert</span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">begin</span><span class="s5">(), </span><span class="s2">'-'</span><span class="s5">);</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_BINARY_LITERAL</span><span class="s5">, </span><span class="s1">num</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>

        <span class="s3">// Caso não haja base especial e tenha lido algum dígito</span>
        <span class="s4">bool </span><span class="s1">read_any </span><span class="s5">= !</span><span class="s1">num</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">read_any</span><span class="s5">) {</span>
            <span class="s1">std::string s </span><span class="s5">= </span><span class="s1">negative ? </span><span class="s2">&quot;-&quot; </span><span class="s1">: </span><span class="s5">(</span><span class="s1">positive ? </span><span class="s2">&quot;+&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s5">);</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">, </span><span class="s1">s</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>

        <span class="s3">// Retorna literal real ou inteiro, conforme o caso</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">negative</span><span class="s5">) </span><span class="s1">num</span><span class="s5">.</span><span class="s1">insert</span><span class="s5">(</span><span class="s1">num</span><span class="s5">.</span><span class="s1">begin</span><span class="s5">(), </span><span class="s2">'-'</span><span class="s5">);</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">is_real</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">, </span><span class="s1">num</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">else </span><span class="s5">{</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">, </span><span class="s1">num</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Parseia literais de tempo, com a sintaxe T# seguido por dígitos e unidade. 
     * @return Token contendo o literal de tempo. 
     */</span>
    <span class="s1">Token parse_time_literal</span><span class="s5">() {</span>
        <span class="s4">int </span><span class="s1">start_line </span><span class="s5">= </span><span class="s1">current_line</span><span class="s5">;</span>
        <span class="s4">int </span><span class="s1">start_col  </span><span class="s5">= </span><span class="s1">current_column</span><span class="s5">;</span>
        <span class="s3">// Consome &quot;T#&quot;</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// 'T'</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// '#'</span>
        <span class="s1">std::string literal </span><span class="s5">= </span><span class="s2">&quot;T#&quot;</span><span class="s5">;</span>
        <span class="s4">bool </span><span class="s1">digit_found </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">std::isdigit</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">peek</span><span class="s5">())) {</span>
            <span class="s1">digit_found </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
            <span class="s1">literal</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
        <span class="s5">}</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">digit_found</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">, </span><span class="s2">&quot;T# sem dígitos&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s3">// Lê a unidade (ex.: s, ms, h)</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">std::isalpha</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">peek</span><span class="s5">())) {</span>
            <span class="s1">literal</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_TIME_LITERAL</span><span class="s5">, </span><span class="s1">literal</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Parseia uma string literal delimitada por aspas simples ou duplas. 
     * @param delimiter Caractere delimitador ('&quot;' ou '\''). 
     * @return Token contendo a string literal. 
     */</span>
    <span class="s1">Token parse_string</span><span class="s5">(</span><span class="s4">char </span><span class="s1">delimiter</span><span class="s5">) {</span>
        <span class="s4">int </span><span class="s1">start_line </span><span class="s5">= </span><span class="s1">current_line</span><span class="s5">;</span>
        <span class="s4">int </span><span class="s1">start_col  </span><span class="s5">= </span><span class="s1">current_column</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome a aspa inicial</span>
        <span class="s1">std::string str</span><span class="s5">;</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s4">true</span><span class="s5">) {</span>
            <span class="s4">char </span><span class="s1">c </span><span class="s5">= </span><span class="s1">peek</span><span class="s5">();</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'</span><span class="s4">\0</span><span class="s2">'</span><span class="s5">) {</span>
                <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Unterminated string on line &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">current_line </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">, </span><span class="s1">str</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s1">delimiter</span><span class="s5">) {</span>
                <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Fecha a string</span>
                <span class="s4">break</span><span class="s5">;</span>
            <span class="s5">}</span>
            <span class="s1">str</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">advance</span><span class="s5">());</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">, </span><span class="s1">str</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Parseia um ponto ou intervalo representado por &quot;..&quot;. 
     * @return Token representando o ponto ou intervalo. 
     */</span>
    <span class="s1">Token parse_range_or_dot</span><span class="s5">() {</span>
        <span class="s4">int </span><span class="s1">start_line </span><span class="s5">= </span><span class="s1">current_line</span><span class="s5">;</span>
        <span class="s4">int </span><span class="s1">start_col  </span><span class="s5">= </span><span class="s1">current_column</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome o primeiro '.'</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'.'</span><span class="s5">) {</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_DOT_DOT</span><span class="s5">, </span><span class="s2">&quot;..&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">, </span><span class="s2">&quot;.&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
    <span class="s5">}</span>

<span class="s4">public</span><span class="s1">:</span>
    <span class="s3">/** 
     * @brief Construtor do Lexer. 
     * @param code Código fonte a ser analisado. 
     */</span>
    <span class="s4">explicit </span><span class="s1">Lexer</span><span class="s5">(</span><span class="s1">std::string code</span><span class="s5">)</span>
        <span class="s1">: input</span><span class="s5">(</span><span class="s1">std::move</span><span class="s5">(</span><span class="s1">code</span><span class="s5">)) {}</span>

    <span class="s3">/** 
     * @brief Retorna o próximo token identificado no input. 
     * @return Próximo token. 
     */</span>
    <span class="s1">Token next_token</span><span class="s5">() {</span>
        <span class="s1">skip_whitespace</span><span class="s5">();</span>
        <span class="s4">char </span><span class="s1">c </span><span class="s5">= </span><span class="s1">peek</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'</span><span class="s4">\0</span><span class="s2">'</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_EOF</span><span class="s5">, </span><span class="s2">&quot;EOF&quot;</span><span class="s5">, </span><span class="s1">current_line</span><span class="s5">, </span><span class="s1">current_column</span><span class="s5">);</span>
        <span class="s5">}</span>

        <span class="s3">// Se for início de comentário &quot;(* ... *)&quot;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'(' </span><span class="s5">&amp;&amp; (</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1 </span><span class="s5">&lt; </span><span class="s1">input</span><span class="s5">.</span><span class="s1">size</span><span class="s5">()) &amp;&amp; </span><span class="s1">input</span><span class="s5">[</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1</span><span class="s5">] == </span><span class="s2">'*'</span><span class="s5">) {</span>
            <span class="s1">skip_comment</span><span class="s5">();</span>
            <span class="s4">return </span><span class="s1">next_token</span><span class="s5">();</span>
        <span class="s5">}</span>

        <span class="s3">// Verifica se é literal de tempo (ex.: T#1s)</span>
        <span class="s4">if </span><span class="s5">((</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'T' </span><span class="s5">|| </span><span class="s1">c </span><span class="s5">== </span><span class="s2">'t'</span><span class="s5">) &amp;&amp; </span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1 </span><span class="s5">&lt; </span><span class="s1">input</span><span class="s5">.</span><span class="s1">size</span><span class="s5">() &amp;&amp; </span><span class="s1">input</span><span class="s5">[</span><span class="s1">pos</span><span class="s5">+</span><span class="s6">1</span><span class="s5">] == </span><span class="s2">'#'</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">parse_time_literal</span><span class="s5">();</span>
        <span class="s5">}</span>

        <span class="s3">// Se o caractere inicia com letra ou '_' -&gt; parse de identificador</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">std::isalpha</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">c</span><span class="s5">) || </span><span class="s1">c </span><span class="s5">== </span><span class="s2">'_'</span><span class="s5">) {</span>
            <span class="s4">int </span><span class="s1">start_line </span><span class="s5">= </span><span class="s1">current_line</span><span class="s5">;</span>
            <span class="s4">int </span><span class="s1">start_col  </span><span class="s5">= </span><span class="s1">current_column</span><span class="s5">;</span>
            <span class="s1">std::string ident </span><span class="s5">= </span><span class="s1">parse_identifier</span><span class="s5">();</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">ident</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">()) {</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">, </span><span class="s1">std::string</span><span class="s5">(</span><span class="s6">1</span><span class="s5">, </span><span class="s1">advance</span><span class="s5">()), </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">TokenId tid </span><span class="s5">= </span><span class="s1">classify_keyword</span><span class="s5">(</span><span class="s1">ident</span><span class="s5">);</span>
            <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">tid</span><span class="s5">, </span><span class="s1">ident</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
        <span class="s5">}</span>

        <span class="s3">// Se o caractere é dígito ou sinal -&gt; parse de número</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">std::isdigit</span><span class="s5">((</span><span class="s4">unsigned char</span><span class="s5">)</span><span class="s1">c</span><span class="s5">) || </span><span class="s1">c </span><span class="s5">== </span><span class="s2">'-' </span><span class="s5">|| </span><span class="s1">c </span><span class="s5">== </span><span class="s2">'+'</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">parse_number</span><span class="s5">();</span>
        <span class="s5">}</span>

        <span class="s3">// Se for string literal</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'&quot;' </span><span class="s5">|| </span><span class="s1">c </span><span class="s5">== </span><span class="s2">'</span><span class="s4">\'</span><span class="s2">'</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">parse_string</span><span class="s5">(</span><span class="s1">c</span><span class="s5">);</span>
        <span class="s5">}</span>

        <span class="s3">// Se for ponto ou intervalo &quot;..&quot;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">c </span><span class="s5">== </span><span class="s2">'.'</span><span class="s5">) {</span>
            <span class="s4">return </span><span class="s1">parse_range_or_dot</span><span class="s5">();</span>
        <span class="s5">}</span>

        <span class="s3">// Tratamento dos demais símbolos e operadores</span>
        <span class="s4">int </span><span class="s1">start_line </span><span class="s5">= </span><span class="s1">current_line</span><span class="s5">;</span>
        <span class="s4">int </span><span class="s1">start_col  </span><span class="s5">= </span><span class="s1">current_column</span><span class="s5">;</span>

        <span class="s4">switch</span><span class="s5">(</span><span class="s1">c</span><span class="s5">) {</span>
            <span class="s4">case </span><span class="s2">':'</span><span class="s1">:</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'='</span><span class="s5">) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                    <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">, </span><span class="s2">&quot;:=&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_COLON</span><span class="s5">, </span><span class="s2">&quot;:&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s4">case </span><span class="s2">';'</span><span class="s1">:</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_SEMICOLON</span><span class="s5">, </span><span class="s2">&quot;;&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s4">case </span><span class="s2">','</span><span class="s1">:</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_COMMA</span><span class="s5">, </span><span class="s2">&quot;,&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s4">case </span><span class="s2">'('</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_LPAREN</span><span class="s5">, </span><span class="s2">&quot;(&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">')'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">, </span><span class="s2">&quot;)&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'['</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">, </span><span class="s2">&quot;[&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">']'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">, </span><span class="s2">&quot;]&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'+'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_PLUS</span><span class="s5">, </span><span class="s2">&quot;+&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'-'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">, </span><span class="s2">&quot;-&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'*'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_MULTIPLY</span><span class="s5">, </span><span class="s2">&quot;*&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'/'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_DIVIDE</span><span class="s5">, </span><span class="s2">&quot;/&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'='</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_IGUAL</span><span class="s5">, </span><span class="s2">&quot;=&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'&gt;'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'='</span><span class="s5">) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                    <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_MAIOR_IGUAL</span><span class="s5">, </span><span class="s2">&quot;&gt;=&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_MAIOR</span><span class="s5">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">case </span><span class="s2">'&lt;'</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'='</span><span class="s5">) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                    <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_MENOR_IGUAL</span><span class="s5">, </span><span class="s2">&quot;&lt;=&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s4">else if </span><span class="s5">(</span><span class="s1">peek</span><span class="s5">() == </span><span class="s2">'&gt;'</span><span class="s5">) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                    <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_DIFERENTE</span><span class="s5">, </span><span class="s2">&quot;&lt;&gt;&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_MENOR</span><span class="s5">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s5">, </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">default</span><span class="s1">:</span>
            <span class="s5">{</span>
                <span class="s4">char </span><span class="s1">inv </span><span class="s5">= </span><span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">return </span><span class="s1">Token</span><span class="s5">(</span><span class="s1">TOK_INVALID</span><span class="s5">, </span><span class="s1">std::string</span><span class="s5">(</span><span class="s6">1</span><span class="s5">, </span><span class="s1">inv</span><span class="s5">), </span><span class="s1">start_line</span><span class="s5">, </span><span class="s1">start_col</span><span class="s5">);</span>
            <span class="s5">}</span>
        <span class="s5">}</span>
    <span class="s5">}</span>

    <span class="s3">/** 
     * @brief Retorna a posição atual do lexer no input. 
     */</span>
    <span class="s1">size_t getPos</span><span class="s5">() </span><span class="s4">const </span><span class="s5">{ </span><span class="s4">return </span><span class="s1">pos</span><span class="s5">; }</span>

    <span class="s3">/** 
     * @brief Retorna o código fonte completo. 
     */</span>
    <span class="s4">const </span><span class="s1">std::string</span><span class="s5">&amp; </span><span class="s1">getInput</span><span class="s5">() </span><span class="s4">const </span><span class="s5">{ </span><span class="s4">return </span><span class="s1">input</span><span class="s5">; }</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Tabela de símbolos simples para variáveis, associando nome ao tipo. 
 */</span>
<span class="s4">class </span><span class="s1">SymbolTable </span><span class="s5">{</span>
<span class="s4">private</span><span class="s1">:</span>
    <span class="s1">std::unordered_map</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">, </span><span class="s1">VarType</span><span class="s5">&gt; </span><span class="s1">table</span><span class="s5">;</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s4">void </span><span class="s1">declareVar</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">name</span><span class="s5">, </span><span class="s1">VarType type</span><span class="s5">) {</span>
        <span class="s1">table</span><span class="s5">[</span><span class="s1">name</span><span class="s5">] = </span><span class="s1">type</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s4">bool </span><span class="s1">isDeclared</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">name</span><span class="s5">) </span><span class="s4">const </span><span class="s5">{</span>
        <span class="s4">return </span><span class="s5">(</span><span class="s1">table</span><span class="s5">.</span><span class="s1">find</span><span class="s5">(</span><span class="s1">name</span><span class="s5">) != </span><span class="s1">table</span><span class="s5">.</span><span class="s1">end</span><span class="s5">());</span>
    <span class="s5">}</span>

    <span class="s1">VarType getType</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">name</span><span class="s5">) </span><span class="s4">const </span><span class="s5">{</span>
        <span class="s4">auto </span><span class="s1">it </span><span class="s5">= </span><span class="s1">table</span><span class="s5">.</span><span class="s1">find</span><span class="s5">(</span><span class="s1">name</span><span class="s5">);</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">it </span><span class="s5">== </span><span class="s1">table</span><span class="s5">.</span><span class="s1">end</span><span class="s5">()) </span><span class="s4">return </span><span class="s1">TYPE_UNKNOWN</span><span class="s5">;</span>
        <span class="s4">return </span><span class="s1">it</span><span class="s5">-&gt;</span><span class="s1">second</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Enumeração dos tipos de usuário para declaração de tipos personalizados. 
 */</span>
<span class="s4">enum </span><span class="s1">UserTypeKind </span><span class="s5">{</span>
    <span class="s1">UTYPE_BASE</span><span class="s5">,       </span><span class="s3">// Tipo base com valor inicial (ex.: REAL)</span>
    <span class="s1">UTYPE_ENUM</span><span class="s5">,       </span><span class="s3">// Enumerado</span>
    <span class="s1">UTYPE_SUBRANGE</span><span class="s5">,   </span><span class="s3">// Subfaixa</span>
    <span class="s1">UTYPE_ARRAY</span><span class="s5">,      </span><span class="s3">// Array</span>
    <span class="s1">UTYPE_STRUCT</span><span class="s5">,     </span><span class="s3">// Struct</span>
    <span class="s1">UTYPE_DERIVED     </span><span class="s3">// Tipo derivado de outro</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Estrutura para armazenar informações sobre tipos definidos pelo usuário. 
 */</span>
<span class="s4">struct </span><span class="s1">UserTypeInfo </span><span class="s5">{</span>
    <span class="s1">UserTypeKind kind</span><span class="s5">;</span>
    <span class="s1">std::string name</span><span class="s5">;      </span><span class="s3">/**&lt; Nome do tipo (ex.: &quot;FREQ&quot;) */</span>
    <span class="s1">std::string baseName</span><span class="s5">;  </span><span class="s3">/**&lt; Nome do tipo base ou do tipo derivado */</span>
    <span class="s4">double </span><span class="s1">initValueNumeric</span><span class="s5">; </span><span class="s3">/**&lt; Valor numérico inicial (se aplicável) */</span>
    <span class="s1">std::string initValueString</span><span class="s5">; </span><span class="s3">/**&lt; Valor inicial como string (se aplicável) */</span>
    <span class="s4">bool </span><span class="s1">hasInitValue </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>

    <span class="s3">// Informações para enumeração</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">&gt; </span><span class="s1">enumValues</span><span class="s5">;</span>
    <span class="s1">std::string enumInit</span><span class="s5">;</span>

    <span class="s3">// Informações para subrange</span>
    <span class="s4">long </span><span class="s1">subrangeLow</span><span class="s5">;</span>
    <span class="s4">long </span><span class="s1">subrangeHigh</span><span class="s5">;</span>

    <span class="s3">// Informações para array</span>
    <span class="s4">long </span><span class="s1">arrayLow</span><span class="s5">;</span>
    <span class="s4">long </span><span class="s1">arrayHigh</span><span class="s5">;</span>
    <span class="s1">std::string arrayElementType</span><span class="s5">; </span><span class="s3">// Tipo dos elementos do array</span>

    <span class="s3">// Informações para struct: lista de campos</span>
    <span class="s4">struct </span><span class="s1">Field </span><span class="s5">{</span>
        <span class="s1">std::string name</span><span class="s5">;</span>
        <span class="s1">std::string type</span><span class="s5">;</span>
        <span class="s1">std::string initValue</span><span class="s5">; </span><span class="s3">// Valor literal opcional para inicialização</span>
    <span class="s5">};</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">Field</span><span class="s5">&gt; </span><span class="s1">structFields</span><span class="s5">;</span>

    <span class="s3">// Para tipos derivados (structs derivados)</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::pair</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">, </span><span class="s1">std::string</span><span class="s5">&gt;&gt; </span><span class="s1">derivedInits</span><span class="s5">;</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Tabela de tipos do usuário, associando nomes a UserTypeInfo. 
 */</span>
<span class="s4">class </span><span class="s1">TypeTable </span><span class="s5">{</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s1">std::unordered_map</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">, </span><span class="s1">UserTypeInfo</span><span class="s5">&gt; </span><span class="s1">types</span><span class="s5">;</span>

    <span class="s4">bool </span><span class="s1">isTypeDeclared</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">name</span><span class="s5">) </span><span class="s4">const </span><span class="s5">{</span>
        <span class="s4">return </span><span class="s5">(</span><span class="s1">types</span><span class="s5">.</span><span class="s1">find</span><span class="s5">(</span><span class="s1">name</span><span class="s5">) != </span><span class="s1">types</span><span class="s5">.</span><span class="s1">end</span><span class="s5">());</span>
    <span class="s5">}</span>
    <span class="s4">void </span><span class="s1">declareType</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">name</span><span class="s5">, </span><span class="s4">const </span><span class="s1">UserTypeInfo </span><span class="s5">&amp;</span><span class="s1">info</span><span class="s5">) {</span>
        <span class="s1">types</span><span class="s5">[</span><span class="s1">name</span><span class="s5">] = </span><span class="s1">info</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">const </span><span class="s1">UserTypeInfo</span><span class="s5">* </span><span class="s1">getTypeInfo</span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">name</span><span class="s5">) </span><span class="s4">const </span><span class="s5">{</span>
        <span class="s4">auto </span><span class="s1">it </span><span class="s5">= </span><span class="s1">types</span><span class="s5">.</span><span class="s1">find</span><span class="s5">(</span><span class="s1">name</span><span class="s5">);</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">it </span><span class="s5">!= </span><span class="s1">types</span><span class="s5">.</span><span class="s1">end</span><span class="s5">()) </span><span class="s4">return </span><span class="s5">&amp;</span><span class="s1">it</span><span class="s5">-&gt;</span><span class="s1">second</span><span class="s5">;</span>
        <span class="s4">return nullptr</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Classe Parser responsável por analisar a estrutura sintática e semântica do código. 
 */</span>
<span class="s4">class </span><span class="s1">Parser </span><span class="s5">{</span>
<span class="s4">private</span><span class="s1">:</span>
    <span class="s1">Lexer </span><span class="s5">&amp;</span><span class="s1">lexer</span><span class="s5">;</span>
    <span class="s1">Token current_token</span><span class="s5">;</span>
    <span class="s1">SymbolTable symtab</span><span class="s5">;  </span><span class="s3">/**&lt; Tabela de símbolos para variáveis */</span>
    <span class="s1">TypeTable typetab</span><span class="s5">;   </span><span class="s3">/**&lt; Tabela de tipos definidos pelo usuário */</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">&gt; </span><span class="s1">code</span><span class="s5">;  </span><span class="s3">/**&lt; Vetor para armazenar código intermediário (IR) */</span>

    <span class="s3">// Funções de parsing de diversos elementos da linguagem</span>
    <span class="s4">void </span><span class="s1">parseProgram</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseVarBlock</span><span class="s5">();</span>
    <span class="s4">bool </span><span class="s1">isVarBlockStart</span><span class="s5">();</span>
    <span class="s4">bool </span><span class="s1">isVarDeclarationStart</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseVarDeclaration</span><span class="s5">(</span><span class="s4">bool </span><span class="s1">isConstBlock</span><span class="s5">, </span><span class="s4">bool </span><span class="s1">isRetainBlock</span><span class="s5">);</span>
    <span class="s1">VarType mapBasicType</span><span class="s5">(</span><span class="s1">TokenId id</span><span class="s5">);</span>
    <span class="s1">VarType parseTypeAndGetVarType</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseStructDeclaration</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseValue</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseNumber</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseInstructions</span><span class="s5">();</span>
    <span class="s4">bool </span><span class="s1">isInstructionStart</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseInstruction</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseAssignment</span><span class="s5">();</span>

    <span class="s3">// Parsing de expressões para gerar código intermediário (IR)</span>
    <span class="s1">std::string parseExpressionToIR</span><span class="s5">();</span>
    <span class="s1">std::string parseTermToIR</span><span class="s5">();</span>
    <span class="s1">std::string parseFactorToIR</span><span class="s5">();</span>

    <span class="s3">// Parsing de estruturas condicionais e laços</span>
    <span class="s4">void </span><span class="s1">parseIfStatement</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseForStatement</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseWhileStatement</span><span class="s5">();</span>
    <span class="s1">std::string parseComparisonToIR</span><span class="s5">();</span>
    <span class="s1">std::string parseConditionToIR</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseRelationalOperator</span><span class="s5">();</span>

    <span class="s4">void </span><span class="s1">parseCondition</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseExpression</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseTerm</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseFactor</span><span class="s5">();</span>

    <span class="s3">// Parsing para inicializadores de array</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::pair</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">,</span><span class="s4">int</span><span class="s5">&gt;&gt; </span><span class="s1">parseArrayInitializer</span><span class="s5">();</span>
    <span class="s1">std::pair</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">,</span><span class="s4">int</span><span class="s5">&gt; </span><span class="s1">parseInitValue</span><span class="s5">();</span>

    <span class="s3">// Parsing do bloco de definição de tipos do usuário</span>
    <span class="s4">void </span><span class="s1">parseTypeBlock</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parseTypeDeclaration</span><span class="s5">();</span>

    <span class="s3">// Funções auxiliares para verificação e avanço de tokens</span>
    <span class="s4">void </span><span class="s1">expect</span><span class="s5">(</span><span class="s1">TokenId expected</span><span class="s5">);</span>
    <span class="s4">bool </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TokenId id</span><span class="s5">);</span>
    <span class="s4">void </span><span class="s1">advance</span><span class="s5">();</span>
    <span class="s4">void </span><span class="s1">parser_error</span><span class="s5">(</span><span class="s4">const </span><span class="s1">Token </span><span class="s5">&amp;</span><span class="s1">tok</span><span class="s5">, </span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">msg</span><span class="s5">);</span>
    <span class="s4">void </span><span class="s1">semantic_error</span><span class="s5">(</span><span class="s4">const </span><span class="s1">Token </span><span class="s5">&amp;</span><span class="s1">tok</span><span class="s5">, </span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">msg</span><span class="s5">);</span>

    <span class="s3">/** 
     * @brief Gera um novo temporário para uso na geração do IR. 
     * @return Nome do temporário. 
     */</span>
    <span class="s1">std::string newTemp</span><span class="s5">() {</span>
        <span class="s4">static int </span><span class="s1">temp_count </span><span class="s5">= </span><span class="s6">0</span><span class="s5">;</span>
        <span class="s4">return </span><span class="s2">&quot;t&quot; </span><span class="s5">+ </span><span class="s1">std::to_string</span><span class="s5">(++</span><span class="s1">temp_count</span><span class="s5">);</span>
    <span class="s5">}</span>

<span class="s4">public</span><span class="s1">:</span>
    <span class="s3">/** 
     * @brief Construtor do Parser. 
     * @param l Referência para o lexer. 
     */</span>
    <span class="s4">explicit </span><span class="s1">Parser</span><span class="s5">(</span><span class="s1">Lexer </span><span class="s5">&amp;</span><span class="s1">l</span><span class="s5">) </span><span class="s1">: lexer</span><span class="s5">(</span><span class="s1">l</span><span class="s5">) {</span>
        <span class="s1">current_token </span><span class="s5">= </span><span class="s1">lexer</span><span class="s5">.</span><span class="s1">next_token</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s3">/** 
     * @brief Inicia o processo de parsing do código. 
     */</span>
    <span class="s4">void </span><span class="s1">parse</span><span class="s5">();</span>
<span class="s5">};</span>

<span class="s3">/** 
 * @brief Avança para o próximo token no input. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::advance</span><span class="s5">() {</span>
    <span class="s1">current_token </span><span class="s5">= </span><span class="s1">lexer</span><span class="s5">.</span><span class="s1">next_token</span><span class="s5">();</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Emite erro de sintaxe e exibe informações úteis (linha, coluna, trecho do código). 
 * @param tok Token onde o erro foi detectado. 
 * @param msg Mensagem de erro. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parser_error</span><span class="s5">(</span><span class="s4">const </span><span class="s1">Token </span><span class="s5">&amp;</span><span class="s1">tok</span><span class="s5">, </span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">msg</span><span class="s5">) {</span>
    <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Erro de sintaxe na linha &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">line </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;, coluna &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">column</span>
              <span class="s5">&lt;&lt; </span><span class="s2">&quot;: &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">msg </span><span class="s5">&lt;&lt; </span><span class="s2">&quot; (encontrado: &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">value </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;)</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>

    <span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">input </span><span class="s5">= </span><span class="s1">lexer</span><span class="s5">.</span><span class="s1">getInput</span><span class="s5">();</span>
    <span class="s1">size_t filePos </span><span class="s5">= </span><span class="s1">lexer</span><span class="s5">.</span><span class="s1">getPos</span><span class="s5">();</span>

    <span class="s3">// Localiza início da linha</span>
    <span class="s1">size_t line_start </span><span class="s5">= </span><span class="s1">input</span><span class="s5">.</span><span class="s1">rfind</span><span class="s5">(</span><span class="s2">'</span><span class="s4">\n</span><span class="s2">'</span><span class="s5">, </span><span class="s1">filePos</span><span class="s5">);</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">line_start </span><span class="s5">== </span><span class="s1">std::string::npos</span><span class="s5">) {</span>
        <span class="s1">line_start </span><span class="s5">= </span><span class="s6">0</span><span class="s5">;</span>
    <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
        <span class="s1">line_start</span><span class="s5">++;</span>
    <span class="s5">}</span>

    <span class="s3">// Localiza fim da linha</span>
    <span class="s1">size_t line_end </span><span class="s5">= </span><span class="s1">input</span><span class="s5">.</span><span class="s1">find</span><span class="s5">(</span><span class="s2">'</span><span class="s4">\n</span><span class="s2">'</span><span class="s5">, </span><span class="s1">filePos</span><span class="s5">);</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">line_end </span><span class="s5">== </span><span class="s1">std::string::npos</span><span class="s5">) {</span>
        <span class="s1">line_end </span><span class="s5">= </span><span class="s1">input</span><span class="s5">.</span><span class="s1">size</span><span class="s5">();</span>
    <span class="s5">}</span>

    <span class="s1">std::string line_str </span><span class="s5">= </span><span class="s1">input</span><span class="s5">.</span><span class="s1">substr</span><span class="s5">(</span><span class="s1">line_start</span><span class="s5">, </span><span class="s1">line_end </span><span class="s5">- </span><span class="s1">line_start</span><span class="s5">);</span>
    <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s1">line_str </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>

    <span class="s3">// Marca a coluna exata onde ocorreu o erro</span>
    <span class="s4">for </span><span class="s5">(</span><span class="s4">int </span><span class="s1">i </span><span class="s5">= </span><span class="s6">1</span><span class="s5">; </span><span class="s1">i </span><span class="s5">&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">column</span><span class="s5">; </span><span class="s1">i</span><span class="s5">++) {</span>
        <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot; &quot;</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;^</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>

    <span class="s4">throw </span><span class="s1">std::runtime_error</span><span class="s5">(</span><span class="s2">&quot;Erro de sintaxe.&quot;</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Emite erro semântico (uso incorreto de variáveis ou tipos). 
 * @param tok Token onde o erro foi detectado. 
 * @param msg Mensagem de erro. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::semantic_error</span><span class="s5">(</span><span class="s4">const </span><span class="s1">Token </span><span class="s5">&amp;</span><span class="s1">tok</span><span class="s5">, </span><span class="s4">const </span><span class="s1">std::string </span><span class="s5">&amp;</span><span class="s1">msg</span><span class="s5">) {</span>
    <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Erro semântico na linha &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">line </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;, coluna &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">column</span>
              <span class="s5">&lt;&lt; </span><span class="s2">&quot;: &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">msg </span><span class="s5">&lt;&lt; </span><span class="s2">&quot; (encontrado: &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">tok</span><span class="s5">.</span><span class="s1">value </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;)</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
    <span class="s4">throw </span><span class="s1">std::runtime_error</span><span class="s5">(</span><span class="s2">&quot;Erro semântico.&quot;</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Verifica se o token atual corresponde ao token esperado e avança. 
 * @param expected TokenId esperado. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::expect</span><span class="s5">(</span><span class="s1">TokenId expected</span><span class="s5">) {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">expected</span><span class="s5">) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
    <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Token esperado não encontrado&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Verifica se o token atual é igual a um dado TokenId. 
 * @param id TokenId a ser comparado. 
 * @return true se corresponder, false caso contrário. 
 */</span>
<span class="s4">bool </span><span class="s1">Parser::check</span><span class="s5">(</span><span class="s1">TokenId id</span><span class="s5">) {</span>
    <span class="s4">return </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">id</span><span class="s5">;</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Mapeia um token representando um tipo básico para a enumeração VarType. 
 * @param id TokenId representando o tipo. 
 * @return VarType correspondente. 
 */</span>
<span class="s1">VarType Parser::mapBasicType</span><span class="s5">(</span><span class="s1">TokenId id</span><span class="s5">) {</span>
    <span class="s4">switch </span><span class="s5">(</span><span class="s1">id</span><span class="s5">) {</span>
        <span class="s4">case </span><span class="s1">TOK_INT:           </span><span class="s4">return </span><span class="s1">TYPE_INT</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_UINT:          </span><span class="s4">return </span><span class="s1">TYPE_UINT</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_REAL:          </span><span class="s4">return </span><span class="s1">TYPE_REAL</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_BYTE:          </span><span class="s4">return </span><span class="s1">TYPE_BYTE</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_BOOL:          </span><span class="s4">return </span><span class="s1">TYPE_BOOL</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_STRING:        </span><span class="s4">return </span><span class="s1">TYPE_STRING</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_DATE_AND_TIME: </span><span class="s4">return </span><span class="s1">TYPE_DATE_AND_TIME</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_TIME:          </span><span class="s4">return </span><span class="s1">TYPE_TIME</span><span class="s5">;</span>
        <span class="s4">case </span><span class="s1">TOK_DWORD:         </span><span class="s4">return </span><span class="s1">TYPE_DWORD</span><span class="s5">;</span>
        <span class="s4">default</span><span class="s1">:                </span><span class="s4">return </span><span class="s1">TYPE_UNKNOWN</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um tipo (básico, array, struct, etc.) e retorna o VarType correspondente. 
 * @return VarType do tipo parseado. 
 */</span>
<span class="s1">VarType Parser::parseTypeAndGetVarType</span><span class="s5">() {</span>
    <span class="s3">// Caso especial: STRING com dimensão (ex.: STRING[50])</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING</span><span class="s5">)) {</span>
        <span class="s1">VarType t </span><span class="s5">= </span><span class="s1">TYPE_STRING</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Dimensão de STRING esperada (STRING[50])&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s3">// Lê a dimensão e avança</span>
            <span class="s4">int </span><span class="s1">dim </span><span class="s5">= </span><span class="s1">std::stoi</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">t</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s3">// Caso especial: TIME</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TIME</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">return </span><span class="s1">TYPE_TIME</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s3">// Se for outro tipo básico</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BOOL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BYTE</span><span class="s5">)</span>
          <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_DATE_AND_TIME</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_DWORD</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_WORD</span><span class="s5">)</span>
          <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_CONSTANT</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_UINT</span><span class="s5">))</span>
    <span class="s5">{</span>
        <span class="s1">VarType t </span><span class="s5">= </span><span class="s1">mapBasicType</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">id</span><span class="s5">);</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">return </span><span class="s1">t</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s3">// Se for ARRAY</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_ARRAY</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">);</span>
        <span class="s1">parseNumber</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_DOT_DOT</span><span class="s5">);</span>
        <span class="s1">parseNumber</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_OF</span><span class="s5">);</span>

        <span class="s1">VarType elemType </span><span class="s5">= </span><span class="s1">parseTypeAndGetVarType</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">elemType </span><span class="s5">== </span><span class="s1">TYPE_INT</span><span class="s5">)    </span><span class="s4">return </span><span class="s1">TYPE_ARRAY_INT</span><span class="s5">;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">elemType </span><span class="s5">== </span><span class="s1">TYPE_UINT</span><span class="s5">)   </span><span class="s4">return </span><span class="s1">TYPE_ARRAY_UINT</span><span class="s5">;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">elemType </span><span class="s5">== </span><span class="s1">TYPE_REAL</span><span class="s5">)   </span><span class="s4">return </span><span class="s1">TYPE_ARRAY_REAL</span><span class="s5">;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">elemType </span><span class="s5">== </span><span class="s1">TYPE_BOOL</span><span class="s5">)   </span><span class="s4">return </span><span class="s1">TYPE_ARRAY_BOOL</span><span class="s5">;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">elemType </span><span class="s5">== </span><span class="s1">TYPE_STRING</span><span class="s5">) </span><span class="s4">return </span><span class="s1">TYPE_ARRAY_STRING</span><span class="s5">;</span>
        <span class="s4">return </span><span class="s1">TYPE_UNKNOWN</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s3">// Se for STRUCT</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRUCT</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
            <span class="s1">parseStructDeclaration</span><span class="s5">();</span>
        <span class="s5">}</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_STRUCT</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">TYPE_UNKNOWN</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Tipo inválido&quot;</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">TYPE_UNKNOWN</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Exemplo de parse de declaração de struct. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseStructDeclaration</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">);</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_COLON</span><span class="s5">);</span>
    <span class="s1">parseTypeAndGetVarType</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_SEMICOLON</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um valor simples (números, strings, booleanos, etc.) usado em atribuições. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseValue</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">) ||</span>
        <span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_HEX_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) ||</span>
        <span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">) ||</span>
        <span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_OCTAL_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BINARY_LITERAL</span><span class="s5">) ||</span>
        <span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_UINT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TIME_LITERAL</span><span class="s5">))</span>
    <span class="s5">{</span>
        <span class="s1">advance</span><span class="s5">();</span>
    <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inválido na atribuição&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um número, verificando se o token atual é um literal numérico. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseNumber</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_HEX_LITERAL</span><span class="s5">)</span>
     <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_OCTAL_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BINARY_LITERAL</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
     <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
         <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Número esperado&quot;</span><span class="s5">);</span>
     <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Verifica se o bloco atual de declaração de variáveis está iniciado. 
 * @return true se o token atual for TOK_VAR. 
 */</span>
<span class="s4">bool </span><span class="s1">Parser::isVarBlockStart</span><span class="s5">() {</span>
    <span class="s4">return </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_VAR</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Verifica se o token atual pode iniciar uma declaração de variável. 
 * @return true se for um identificador. 
 */</span>
<span class="s4">bool </span><span class="s1">Parser::isVarDeclarationStart</span><span class="s5">() {</span>
    <span class="s4">return </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma declaração de variável, possivelmente com inicialização. 
 * @param isConstBlock Indica se é um bloco de constantes. 
 * @param isRetainBlock Indica se é um bloco com retenção. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseVarDeclaration</span><span class="s5">(</span><span class="s4">bool </span><span class="s1">isConstBlock</span><span class="s5">, </span><span class="s4">bool </span><span class="s1">isRetainBlock</span><span class="s5">) {</span>
    <span class="s1">Token varName </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">);</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_COLON</span><span class="s5">);</span>
    <span class="s1">VarType varType </span><span class="s5">= </span><span class="s1">parseTypeAndGetVarType</span><span class="s5">();</span>

    <span class="s4">bool </span><span class="s1">initialized </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
            <span class="s3">// Caso de inicialização de array (a implementar se necessário)</span>
        <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
            <span class="s3">// Inicialização escalar</span>
            <span class="s1">Token lit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)</span>
             <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">)</span>
             <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_HEX_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_OCTAL_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BINARY_LITERAL</span><span class="s5">)</span>
             <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_UINT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TIME_LITERAL</span><span class="s5">))</span>
            <span class="s5">{</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">lit</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_INT_LITERAL </span><span class="s5">|| </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">) {</span>
                    <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM &quot; </span><span class="s5">+ </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
                <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">lit</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) {</span>
                    <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM </span><span class="s4">\&quot;</span><span class="s2">&quot; </span><span class="s5">+ </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot;</span><span class="s4">\&quot; </span><span class="s2">&quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
                <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">lit</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_TRUE</span><span class="s5">) {</span>
                    <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM 1 &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
                <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">lit</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_FALSE</span><span class="s5">) {</span>
                    <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM 0 &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
                <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">lit</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_TIME_LITERAL</span><span class="s5">) {</span>
                    <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_TIME &quot; </span><span class="s5">+ </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;STORE &quot; </span><span class="s5">+ </span><span class="s1">temp </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
                <span class="s1">initialized </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
            <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inválido na atribuição&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
        <span class="s5">}</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_SEMICOLON</span><span class="s5">);</span>
    <span class="s1">symtab</span><span class="s5">.</span><span class="s1">declareVar</span><span class="s5">(</span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value</span><span class="s5">, </span><span class="s1">varType</span><span class="s5">);</span>

    <span class="s3">// Opcional: tratamento especial para constantes</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">isConstBlock</span><span class="s5">) {</span>
        <span class="s1">std::cout </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Variável/Constante '&quot; </span><span class="s5">&lt;&lt; </span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;' declarada como CONSTANT.</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Exemplo de parse de inicializador de array. 
 * @return Vetor de pares contendo o valor inicial e o número de repetições. 
 */</span>
<span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::pair</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">,</span><span class="s4">int</span><span class="s5">&gt;&gt; </span><span class="s1">Parser::parseArrayInitializer</span><span class="s5">() {</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::pair</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">,</span><span class="s4">int</span><span class="s5">&gt;&gt; </span><span class="s1">values</span><span class="s5">;</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">);</span>
    <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">)) {</span>
        <span class="s4">do </span><span class="s5">{</span>
            <span class="s1">values</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">parseInitValue</span><span class="s5">());</span>
        <span class="s5">} </span><span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_COMMA</span><span class="s5">) &amp;&amp; (</span><span class="s1">advance</span><span class="s5">(), </span><span class="s4">true</span><span class="s5">));</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
    <span class="s4">return </span><span class="s1">values</span><span class="s5">;</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um valor de inicialização para arrays, podendo ter repetição. 
 * @return Par contendo o valor e o número de repetições. 
 */</span>
<span class="s1">std::pair</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">,</span><span class="s4">int</span><span class="s5">&gt; </span><span class="s1">Parser::parseInitValue</span><span class="s5">() {</span>
    <span class="s1">std::string val </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
    <span class="s4">int </span><span class="s1">rep </span><span class="s5">= </span><span class="s6">1</span><span class="s5">;</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LPAREN</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">)) {</span>
            <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Número esperado após '('&quot;</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">int </span><span class="s1">count </span><span class="s5">= </span><span class="s1">std::stoi</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">);</span>
        <span class="s1">rep </span><span class="s5">= </span><span class="s1">count</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">return </span><span class="s5">{</span><span class="s1">val</span><span class="s5">, </span><span class="s1">rep</span><span class="s5">};</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Verifica se o token atual pode iniciar uma instrução. 
 * @return true se for o início de uma instrução. 
 */</span>
<span class="s4">bool </span><span class="s1">Parser::isInstructionStart</span><span class="s5">() {</span>
    <span class="s4">return </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)</span>
        <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IF</span><span class="s5">)</span>
        <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FOR</span><span class="s5">)</span>
        <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_WHILE</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia as instruções do corpo do programa. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseInstructions</span><span class="s5">() {</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">isInstructionStart</span><span class="s5">()) {</span>
        <span class="s1">parseInstruction</span><span class="s5">();</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma única instrução (atribuição, condicional, laço, etc.). 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseInstruction</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
        <span class="s1">parseAssignment</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IF</span><span class="s5">)) {</span>
        <span class="s1">parseIfStatement</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FOR</span><span class="s5">)) {</span>
        <span class="s1">parseForStatement</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_WHILE</span><span class="s5">)) {</span>
        <span class="s1">parseWhileStatement</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Instrução inválida&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma atribuição, possivelmente com acesso a arrays. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseAssignment</span><span class="s5">() {</span>
    <span class="s3">// Lê o nome da variável</span>
    <span class="s1">Token varName </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">);</span>

    <span class="s3">// Trata possíveis índices para acesso a arrays</span>
    <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">&gt; </span><span class="s1">indices</span><span class="s5">;</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">(); </span><span class="s3">// Consome '['</span>
        <span class="s1">std::string idxIR </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
        <span class="s1">indices</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">idxIR</span><span class="s5">);</span>
    <span class="s5">}</span>

    <span class="s3">// Espera o operador de atribuição &quot;:=&quot;</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">);</span>

    <span class="s3">// Parseia a expressão do lado direito</span>
    <span class="s1">std::string rhs </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>

    <span class="s3">// Espera o ponto e vírgula para terminar a instrução</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_SEMICOLON</span><span class="s5">);</span>

    <span class="s3">// Gera a instrução IR para a atribuição</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">indices</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">()) {</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;STORE &quot; </span><span class="s5">+ </span><span class="s1">rhs </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
    <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;STORE_INDEX &quot; </span><span class="s5">+ </span><span class="s1">rhs </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">indices</span><span class="s5">[</span><span class="s6">0</span><span class="s5">]);</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma expressão aritmética e gera o IR correspondente. 
 * @return Nome do temporário que armazena o resultado. 
 */</span>
<span class="s1">std::string Parser::parseExpressionToIR</span><span class="s5">() {</span>
    <span class="s1">std::string left </span><span class="s5">= </span><span class="s1">parseTermToIR</span><span class="s5">();</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_PLUS</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">)) {</span>
        <span class="s1">Token op </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string right </span><span class="s5">= </span><span class="s1">parseTermToIR</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">((</span><span class="s1">op</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_PLUS ? </span><span class="s2">&quot;ADD&quot; </span><span class="s1">: </span><span class="s2">&quot;SUB&quot;</span><span class="s5">) + </span><span class="s1">std::string</span><span class="s5">(</span><span class="s2">&quot; &quot;</span><span class="s5">) + </span><span class="s1">left </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">right </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s1">left </span><span class="s5">= </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">return </span><span class="s1">left</span><span class="s5">;</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um termo (parte da expressão) e gera o IR correspondente. 
 * @return Nome do temporário que armazena o resultado. 
 */</span>
<span class="s1">std::string Parser::parseTermToIR</span><span class="s5">() {</span>
    <span class="s1">std::string left </span><span class="s5">= </span><span class="s1">parseFactorToIR</span><span class="s5">();</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TIME_LITERAL</span><span class="s5">)) {</span>
        <span class="s1">Token lit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_TIME &quot; </span><span class="s5">+ </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MULTIPLY</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_DIVIDE</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MOD</span><span class="s5">)) {</span>
        <span class="s1">Token op </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string right </span><span class="s5">= </span><span class="s1">parseFactorToIR</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">std::string instr</span><span class="s5">;</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">op</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_MULTIPLY</span><span class="s5">) </span><span class="s1">instr </span><span class="s5">= </span><span class="s2">&quot;MUL&quot;</span><span class="s5">;</span>
        <span class="s4">else if </span><span class="s5">(</span><span class="s1">op</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_DIVIDE</span><span class="s5">) </span><span class="s1">instr </span><span class="s5">= </span><span class="s2">&quot;DIV&quot;</span><span class="s5">;</span>
        <span class="s4">else </span><span class="s1">instr </span><span class="s5">= </span><span class="s2">&quot;MOD&quot;</span><span class="s5">;</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">instr </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">left </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">right </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s1">left </span><span class="s5">= </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">return </span><span class="s1">left</span><span class="s5">;</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um fator (parte atômica da expressão) e gera o IR. 
 * @return Nome do temporário com o resultado. 
 */</span>
<span class="s1">std::string Parser::parseFactorToIR</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LPAREN</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string res </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
        <span class="s1">Token varName </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">symtab</span><span class="s5">.</span><span class="s1">isDeclared</span><span class="s5">(</span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value</span><span class="s5">)) {</span>
            <span class="s1">semantic_error</span><span class="s5">(</span><span class="s1">varName</span><span class="s5">, </span><span class="s2">&quot;Uso de variável não declarada&quot;</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s1">VarType varType </span><span class="s5">= </span><span class="s1">symtab</span><span class="s5">.</span><span class="s1">getType</span><span class="s5">(</span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
        <span class="s1">std::vector</span><span class="s5">&lt;</span><span class="s1">std::string</span><span class="s5">&gt; </span><span class="s1">indices</span><span class="s5">;</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">varType </span><span class="s5">!= </span><span class="s1">TYPE_ARRAY_INT </span><span class="s5">&amp;&amp; </span><span class="s1">varType </span><span class="s5">!= </span><span class="s1">TYPE_ARRAY_REAL</span>
                <span class="s5">&amp;&amp; </span><span class="s1">varType </span><span class="s5">!= </span><span class="s1">TYPE_ARRAY_BOOL </span><span class="s5">&amp;&amp; </span><span class="s1">varType </span><span class="s5">!= </span><span class="s1">TYPE_ARRAY_STRING</span><span class="s5">) {</span>
                <span class="s1">semantic_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Acesso a array em variável não-array&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s1">std::string idx </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">varType </span><span class="s5">== </span><span class="s1">TYPE_ARRAY_INT</span><span class="s5">) </span><span class="s1">varType </span><span class="s5">= </span><span class="s1">TYPE_INT</span><span class="s5">;</span>
            <span class="s4">else if </span><span class="s5">(</span><span class="s1">varType </span><span class="s5">== </span><span class="s1">TYPE_ARRAY_REAL</span><span class="s5">) </span><span class="s1">varType </span><span class="s5">= </span><span class="s1">TYPE_REAL</span><span class="s5">;</span>
            <span class="s4">else if </span><span class="s5">(</span><span class="s1">varType </span><span class="s5">== </span><span class="s1">TYPE_ARRAY_BOOL</span><span class="s5">) </span><span class="s1">varType </span><span class="s5">= </span><span class="s1">TYPE_BOOL</span><span class="s5">;</span>
            <span class="s4">else if </span><span class="s5">(</span><span class="s1">varType </span><span class="s5">== </span><span class="s1">TYPE_ARRAY_STRING</span><span class="s5">) </span><span class="s1">varType </span><span class="s5">= </span><span class="s1">TYPE_STRING</span><span class="s5">;</span>
            <span class="s1">indices</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">idx</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">indices</span><span class="s5">.</span><span class="s1">empty</span><span class="s5">()) {</span>
            <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD &quot; </span><span class="s5">+ </span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
            <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_INDEX &quot; </span><span class="s5">+ </span><span class="s1">varName</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">indices</span><span class="s5">[</span><span class="s6">0</span><span class="s5">] + </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)) {</span>
        <span class="s1">Token lit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM &quot; </span><span class="s5">+ </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">)) {</span>
        <span class="s1">Token lit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM </span><span class="s4">\&quot;</span><span class="s2">&quot; </span><span class="s5">+ </span><span class="s1">lit</span><span class="s5">.</span><span class="s1">value </span><span class="s5">+ </span><span class="s2">&quot;</span><span class="s4">\&quot; </span><span class="s2">&quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">)) {</span>
        <span class="s1">Token lit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM 1 &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">)) {</span>
        <span class="s1">Token lit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOAD_IMM 0 &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Fator inválido&quot;</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s2">&quot;&quot;</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma estrutura de repetição &quot;FOR&quot; e suas instruções. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseForStatement</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_FOR</span><span class="s5">);</span>
    <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Identificador esperado após FOR&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
    <span class="s1">Token loopVar </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
    <span class="s1">advance</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">);</span>
    <span class="s1">std::string initExpr </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_TO</span><span class="s5">);</span>
    <span class="s1">std::string finalExpr </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
    <span class="s1">std::string byExpr</span><span class="s5">;</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BY</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">byExpr </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_DO</span><span class="s5">);</span>
    <span class="s1">parseInstructions</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_FOR</span><span class="s5">);</span>
    <span class="s3">// Aqui pode-se gerar IR específico para o laço FOR, se desejado.</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma estrutura de repetição &quot;WHILE&quot;. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseWhileStatement</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_WHILE</span><span class="s5">);</span>
    <span class="s1">std::string condIR </span><span class="s5">= </span><span class="s1">parseConditionToIR</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_DO</span><span class="s5">);</span>
    <span class="s1">parseInstructions</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_WHILE</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma estrutura condicional &quot;IF&quot; com suporte a ELSE. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseIfStatement</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_IF</span><span class="s5">);</span>
    <span class="s1">std::string cond </span><span class="s5">= </span><span class="s1">parseConditionToIR</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_THEN</span><span class="s5">);</span>
    <span class="s1">parseInstructions</span><span class="s5">();</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_ELSE</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">parseInstructions</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_IF</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma comparação (ex.: expr &lt; expr) e gera o IR. 
 * @return Nome do temporário com o resultado da comparação. 
 */</span>
<span class="s1">std::string Parser::parseComparisonToIR</span><span class="s5">() {</span>
    <span class="s1">std::string left </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IGUAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_DIFERENTE</span><span class="s5">) ||</span>
        <span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MENOR</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MENOR_IGUAL</span><span class="s5">) ||</span>
        <span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MAIOR</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MAIOR_IGUAL</span><span class="s5">))</span>
    <span class="s5">{</span>
        <span class="s1">Token op </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">parseRelationalOperator</span><span class="s5">();</span>
        <span class="s1">std::string right </span><span class="s5">= </span><span class="s1">parseExpressionToIR</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s1">std::string instr</span><span class="s5">;</span>
        <span class="s4">switch </span><span class="s5">(</span><span class="s1">op</span><span class="s5">.</span><span class="s1">id</span><span class="s5">) {</span>
            <span class="s4">case </span><span class="s1">TOK_IGUAL:        instr </span><span class="s5">= </span><span class="s2">&quot;COMP_EQ&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
            <span class="s4">case </span><span class="s1">TOK_DIFERENTE:    instr </span><span class="s5">= </span><span class="s2">&quot;COMP_NE&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
            <span class="s4">case </span><span class="s1">TOK_MENOR:        instr </span><span class="s5">= </span><span class="s2">&quot;COMP_LT&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
            <span class="s4">case </span><span class="s1">TOK_MENOR_IGUAL:  instr </span><span class="s5">= </span><span class="s2">&quot;COMP_LE&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
            <span class="s4">case </span><span class="s1">TOK_MAIOR:        instr </span><span class="s5">= </span><span class="s2">&quot;COMP_GT&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
            <span class="s4">case </span><span class="s1">TOK_MAIOR_IGUAL:  instr </span><span class="s5">= </span><span class="s2">&quot;COMP_GE&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
            <span class="s4">default</span><span class="s1">:               instr </span><span class="s5">= </span><span class="s2">&quot;COMP_UNKNOWN&quot;</span><span class="s5">; </span><span class="s4">break</span><span class="s5">;</span>
        <span class="s5">}</span>
        <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">instr </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">left </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">right </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s4">return </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">return </span><span class="s1">left</span><span class="s5">;</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma condição lógica (com operadores AND/OR) e gera o IR. 
 * @return Nome do temporário com o resultado da condição. 
 */</span>
<span class="s1">std::string Parser::parseConditionToIR</span><span class="s5">() {</span>
    <span class="s1">std::string left </span><span class="s5">= </span><span class="s1">parseComparisonToIR</span><span class="s5">();</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_AND</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_OR</span><span class="s5">)) {</span>
        <span class="s1">Token op </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">std::string right </span><span class="s5">= </span><span class="s1">parseComparisonToIR</span><span class="s5">();</span>
        <span class="s1">std::string temp </span><span class="s5">= </span><span class="s1">newTemp</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">op</span><span class="s5">.</span><span class="s1">id </span><span class="s5">== </span><span class="s1">TOK_AND</span><span class="s5">) {</span>
            <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOGICAL_AND &quot; </span><span class="s5">+ </span><span class="s1">left </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">right </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
            <span class="s1">code</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s2">&quot;LOGICAL_OR &quot; </span><span class="s5">+ </span><span class="s1">left </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">right </span><span class="s5">+ </span><span class="s2">&quot; &quot; </span><span class="s5">+ </span><span class="s1">temp</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s1">left </span><span class="s5">= </span><span class="s1">temp</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">return </span><span class="s1">left</span><span class="s5">;</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um operador relacional e avança o token. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseRelationalOperator</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IGUAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_DIFERENTE</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MENOR</span><span class="s5">)</span>
     <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MENOR_IGUAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MAIOR</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MAIOR_IGUAL</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
     <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
         <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Operador relacional esperado&quot;</span><span class="s5">);</span>
     <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma condição simples (expressão relacional). 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseCondition</span><span class="s5">() {</span>
    <span class="s1">parseExpression</span><span class="s5">();</span>
    <span class="s1">parseRelationalOperator</span><span class="s5">();</span>
    <span class="s1">parseExpression</span><span class="s5">();</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma expressão aritmética. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseExpression</span><span class="s5">() {</span>
    <span class="s1">parseTerm</span><span class="s5">();</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_PLUS</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">parseTerm</span><span class="s5">();</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um termo de uma expressão. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseTerm</span><span class="s5">() {</span>
    <span class="s1">parseFactor</span><span class="s5">();</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MULTIPLY</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_DIVIDE</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MOD</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">parseFactor</span><span class="s5">();</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia um fator, que pode ser uma expressão entre parênteses, identificador ou literal. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseFactor</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LPAREN</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">parseExpression</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">);</span>
    <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s1">parseExpression</span><span class="s5">();</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
        <span class="s5">}</span>
    <span class="s5">} </span><span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)</span>
               <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
    <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Fator inválido&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia o programa completo, iniciando pela palavra-chave PROGRAM e finalizando com END_PROGRAM. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseProgram</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_PROGRAM</span><span class="s5">);</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">);</span>

    <span class="s3">// Parseia blocos de definição de tipos, se houver</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TYPE</span><span class="s5">)) {</span>
        <span class="s1">parseTypeBlock</span><span class="s5">();</span>
    <span class="s5">}</span>

    <span class="s3">// Parseia blocos de declaração de variáveis</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">isVarBlockStart</span><span class="s5">()) {</span>
        <span class="s1">parseVarBlock</span><span class="s5">();</span>
    <span class="s5">}</span>

    <span class="s3">// Parseia as instruções do corpo do programa</span>
    <span class="s1">parseInstructions</span><span class="s5">();</span>

    <span class="s3">// Finaliza o programa com END_PROGRAM</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_PROGRAM</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia o bloco de definição de tipos (TYPE ... END_TYPE). 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseTypeBlock</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_TYPE</span><span class="s5">);</span>
    <span class="s4">while </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_END_TYPE</span><span class="s5">) &amp;&amp; </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">id </span><span class="s5">!= </span><span class="s1">TOK_EOF</span><span class="s5">) {</span>
        <span class="s1">parseTypeDeclaration</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_TYPE</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia o bloco de declaração de variáveis (VAR ... END_VAR). 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseVarBlock</span><span class="s5">() {</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_VAR</span><span class="s5">);</span>
    <span class="s4">bool </span><span class="s1">isConstBlock </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
    <span class="s4">bool </span><span class="s1">isRetainBlock </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_CONSTANT</span><span class="s5">)) {</span>
        <span class="s1">isConstBlock </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_RETAIN</span><span class="s5">)) {</span>
        <span class="s1">isRetainBlock </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">while </span><span class="s5">(</span><span class="s1">isVarDeclarationStart</span><span class="s5">()) {</span>
        <span class="s1">parseVarDeclaration</span><span class="s5">(</span><span class="s1">isConstBlock</span><span class="s5">, </span><span class="s1">isRetainBlock</span><span class="s5">);</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_VAR</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Parseia uma declaração de tipo do usuário. 
 * Exemplo: FREQ : REAL := 50.0; 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parseTypeDeclaration</span><span class="s5">() {</span>
    <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Nome de tipo esperado&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
    <span class="s1">std::string typeName </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
    <span class="s1">advance</span><span class="s5">();</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_COLON</span><span class="s5">);</span>

    <span class="s1">UserTypeInfo info</span><span class="s5">;</span>
    <span class="s1">info</span><span class="s5">.</span><span class="s1">name </span><span class="s5">= </span><span class="s1">typeName</span><span class="s5">;</span>
    <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_BASE</span><span class="s5">;</span>

    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LPAREN</span><span class="s5">)) {</span>
        <span class="s3">// Pode ser enum ou subrange (aqui trata como enum)</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">)) {</span>
            <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Sintaxe de subrange incompleta (falta base type antes do '(').&quot;</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">else </span><span class="s5">{</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_ENUM</span><span class="s5">;</span>
            <span class="s4">while </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">)) {</span>
                <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
                    <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Identificador de enumerador esperado&quot;</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s1">info</span><span class="s5">.</span><span class="s1">enumValues</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_COMMA</span><span class="s5">)) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
                    <span class="s4">break</span><span class="s5">;</span>
                <span class="s5">}</span>
            <span class="s5">}</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">);</span>
        <span class="s5">}</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BOOL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BYTE</span><span class="s5">)</span>
        <span class="s5">|| </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_UINT</span><span class="s5">)) {</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">baseName </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_BASE</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
            <span class="s3">// Trata subrange</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_SUBRANGE</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inteiro esperado para limite inferior do subrange&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s4">bool </span><span class="s1">neg </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
            <span class="s4">long </span><span class="s1">lower </span><span class="s5">= </span><span class="s6">0</span><span class="s5">;</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">)) {</span>
                <span class="s1">neg </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
                <span class="s1">advance</span><span class="s5">();</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inteiro esperado apos '-'&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">lower </span><span class="s5">= </span><span class="s1">std::stol</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">neg</span><span class="s5">) </span><span class="s1">lower </span><span class="s5">= -</span><span class="s1">lower</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_DOT_DOT</span><span class="s5">);</span>
            <span class="s1">neg </span><span class="s5">= </span><span class="s4">false</span><span class="s5">;</span>
            <span class="s4">long </span><span class="s1">upper </span><span class="s5">= </span><span class="s6">0</span><span class="s5">;</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_MINUS</span><span class="s5">)) {</span>
                <span class="s1">neg </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
                <span class="s1">advance</span><span class="s5">();</span>
            <span class="s5">}</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inteiro esperado para limite superior do subrange&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">upper </span><span class="s5">= </span><span class="s1">std::stol</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">neg</span><span class="s5">) </span><span class="s1">upper </span><span class="s5">= -</span><span class="s1">upper</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">);</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">subrangeLow </span><span class="s5">= </span><span class="s1">lower</span><span class="s5">;</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">subrangeHigh </span><span class="s5">= </span><span class="s1">upper</span><span class="s5">;</span>
        <span class="s5">}</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_ARRAY</span><span class="s5">)) {</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_ARRAY</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">);</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">)) {</span>
            <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inteiro esperado para indice inferior do array&quot;</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">long </span><span class="s1">low </span><span class="s5">= </span><span class="s1">std::stol</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_DOT_DOT</span><span class="s5">);</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">)) {</span>
            <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor inteiro esperado para indice superior do array&quot;</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">long </span><span class="s1">high </span><span class="s5">= </span><span class="s1">std::stol</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RBRACKET</span><span class="s5">);</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_OF</span><span class="s5">);</span>
        <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">) &amp;&amp;</span>
            <span class="s5">!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BOOL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BYTE</span><span class="s5">) &amp;&amp;</span>
            <span class="s5">!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_UINT</span><span class="s5">)) {</span>
            <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Tipo esperado após OF&quot;</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s1">std::string arrType </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">arrayLow </span><span class="s5">= </span><span class="s1">low</span><span class="s5">;</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">arrayHigh </span><span class="s5">= </span><span class="s1">high</span><span class="s5">;</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">arrayElementType </span><span class="s5">= </span><span class="s1">arrType</span><span class="s5">;</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRUCT</span><span class="s5">)) {</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_STRUCT</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">while </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_END_STRUCT</span><span class="s5">)) {</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Nome de campo esperado&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">UserTypeInfo::Field f</span><span class="s5">;</span>
            <span class="s1">f</span><span class="s5">.</span><span class="s1">name </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_COLON</span><span class="s5">);</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">) &amp;&amp;</span>
                <span class="s5">!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BOOL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING</span><span class="s5">) &amp;&amp;</span>
                <span class="s5">!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_BYTE</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_UINT</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Tipo de campo esperado&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">f</span><span class="s5">.</span><span class="s1">type </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">)) {</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)</span>
                    <span class="s5">&amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">)) {</span>
                    <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor literal esperado para inicialização de campo&quot;</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s1">f</span><span class="s5">.</span><span class="s1">initValue </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
                <span class="s1">advance</span><span class="s5">();</span>
            <span class="s5">}</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_SEMICOLON</span><span class="s5">);</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">structFields</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">(</span><span class="s1">f</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_END_STRUCT</span><span class="s5">);</span>
    <span class="s5">}</span>
    <span class="s4">else if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">= </span><span class="s1">UTYPE_DERIVED</span><span class="s5">;</span>
        <span class="s1">info</span><span class="s5">.</span><span class="s1">baseName </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
        <span class="s1">advance</span><span class="s5">();</span>
    <span class="s5">}</span>
    <span class="s4">else </span><span class="s5">{</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Tipo de dado não reconhecido&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>

    <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">)) {</span>
        <span class="s1">advance</span><span class="s5">();</span>
        <span class="s4">if </span><span class="s5">(</span><span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">== </span><span class="s1">UTYPE_DERIVED </span><span class="s5">&amp;&amp; </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LPAREN</span><span class="s5">)) {</span>
            <span class="s1">advance</span><span class="s5">();</span>
            <span class="s4">while </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">)) {</span>
                <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
                    <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Nome de campo esperado em init do type derivado&quot;</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s1">std::string fld </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_ATRIBUICAO</span><span class="s5">);</span>
                <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)</span>
                    <span class="s5">&amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">)) {</span>
                    <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Literal esperado para init de campo&quot;</span><span class="s5">);</span>
                <span class="s5">}</span>
                <span class="s1">std::string val </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
                <span class="s1">advance</span><span class="s5">();</span>
                <span class="s1">info</span><span class="s5">.</span><span class="s1">derivedInits</span><span class="s5">.</span><span class="s1">push_back</span><span class="s5">({</span><span class="s1">fld</span><span class="s5">, </span><span class="s1">val</span><span class="s5">});</span>
                <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_COMMA</span><span class="s5">)) {</span>
                    <span class="s1">advance</span><span class="s5">();</span>
                <span class="s5">} </span><span class="s4">else </span><span class="s5">{</span>
                    <span class="s4">break</span><span class="s5">;</span>
                <span class="s5">}</span>
            <span class="s5">}</span>
            <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_RPAREN</span><span class="s5">);</span>
        <span class="s5">}</span>
        <span class="s4">else if </span><span class="s5">(</span><span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">== </span><span class="s1">UTYPE_BASE </span><span class="s5">|| </span><span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">== </span><span class="s1">UTYPE_SUBRANGE</span><span class="s5">) {</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)</span>
                <span class="s5">&amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_STRING_LITERAL</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_TRUE</span><span class="s5">) &amp;&amp; !</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_FALSE</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Valor literal inválido para init do tipo base/subrange&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">hasInitValue </span><span class="s5">= </span><span class="s4">true</span><span class="s5">;</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">initValueString </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
            <span class="s4">if </span><span class="s5">(</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_INT_LITERAL</span><span class="s5">) || </span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_REAL_LITERAL</span><span class="s5">)) {</span>
                <span class="s1">info</span><span class="s5">.</span><span class="s1">initValueNumeric </span><span class="s5">= </span><span class="s1">std::stod</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">advance</span><span class="s5">();</span>
        <span class="s5">}</span>
        <span class="s4">else if </span><span class="s5">(</span><span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">== </span><span class="s1">UTYPE_ENUM</span><span class="s5">) {</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_IDENTIFIER</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Enumerador esperado para init do enum&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
            <span class="s1">info</span><span class="s5">.</span><span class="s1">enumInit </span><span class="s5">= </span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">value</span><span class="s5">;</span>
            <span class="s1">advance</span><span class="s5">();</span>
        <span class="s5">}</span>
        <span class="s4">else if </span><span class="s5">(</span><span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">== </span><span class="s1">UTYPE_ARRAY</span><span class="s5">) {</span>
            <span class="s4">if </span><span class="s5">(!</span><span class="s1">check</span><span class="s5">(</span><span class="s1">TOK_LBRACKET</span><span class="s5">)) {</span>
                <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Esperado '[' para init de array&quot;</span><span class="s5">);</span>
            <span class="s5">}</span>
        <span class="s5">}</span>
        <span class="s4">else if </span><span class="s5">(</span><span class="s1">info</span><span class="s5">.</span><span class="s1">kind </span><span class="s5">== </span><span class="s1">UTYPE_STRUCT</span><span class="s5">) {</span>
            <span class="s3">// Inicialização de struct pode ser implementada conforme necessidade.</span>
        <span class="s5">}</span>
    <span class="s5">}</span>
    <span class="s1">expect</span><span class="s5">(</span><span class="s1">TOK_SEMICOLON</span><span class="s5">);</span>
    <span class="s1">typetab</span><span class="s5">.</span><span class="s1">declareType</span><span class="s5">(</span><span class="s1">typeName</span><span class="s5">, </span><span class="s1">info</span><span class="s5">);</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Inicia o processo de parsing do programa, análise semântica e geração do código intermediário. 
 */</span>
<span class="s4">void </span><span class="s1">Parser::parse</span><span class="s5">() {</span>
    <span class="s1">parseProgram</span><span class="s5">();</span>
    <span class="s4">if </span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">.</span><span class="s1">id </span><span class="s5">!= </span><span class="s1">TOK_EOF</span><span class="s5">) {</span>
        <span class="s1">parser_error</span><span class="s5">(</span><span class="s1">current_token</span><span class="s5">, </span><span class="s2">&quot;Tokens extras após fim do programa&quot;</span><span class="s5">);</span>
    <span class="s5">}</span>
    <span class="s1">std::cout </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;=== CODE GENERATION (IR) ===</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
    <span class="s4">for </span><span class="s5">(</span><span class="s4">const auto </span><span class="s5">&amp;</span><span class="s1">instr : code</span><span class="s5">) {</span>
        <span class="s1">std::cout </span><span class="s5">&lt;&lt; </span><span class="s1">instr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
    <span class="s5">}</span>
<span class="s5">}</span>

<span class="s3">/** 
 * @brief Função principal que executa o lexer, parser e gera o IR. 
 */</span>
<span class="s4">int </span><span class="s1">main</span><span class="s5">(</span><span class="s4">int </span><span class="s1">argc</span><span class="s5">, </span><span class="s4">char </span><span class="s5">**</span><span class="s1">argv</span><span class="s5">) {</span>
    <span class="s3">// Define o nome do arquivo a partir de argumento ou usa um padrão</span>
    <span class="s1">std::string nomeArquivo </span><span class="s5">= (</span><span class="s1">argc </span><span class="s5">&gt; </span><span class="s6">1</span><span class="s5">) </span><span class="s1">? argv</span><span class="s5">[</span><span class="s6">1</span><span class="s5">]</span>
                                         <span class="s1">: </span><span class="s2">&quot;/home/kaynan/Documentos/desenvolvimento/c++/Compilador-st-am/teste-1.st&quot;</span><span class="s5">;</span>

    <span class="s1">std::ifstream file</span><span class="s5">(</span><span class="s1">nomeArquivo</span><span class="s5">);</span>
    <span class="s4">if </span><span class="s5">(!</span><span class="s1">file</span><span class="s5">) {</span>
        <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Não foi possível abrir o arquivo: &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">nomeArquivo </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
        <span class="s4">return </span><span class="s6">1</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s3">// Lê o conteúdo completo do arquivo</span>
    <span class="s1">std::string code</span><span class="s5">((</span><span class="s1">std::istreambuf_iterator</span><span class="s5">&lt;</span><span class="s4">char</span><span class="s5">&gt;(</span><span class="s1">file</span><span class="s5">)),</span>
                     <span class="s1">std::istreambuf_iterator</span><span class="s5">&lt;</span><span class="s4">char</span><span class="s5">&gt;());</span>

    <span class="s3">// Inicializa o lexer e imprime tokens para debug</span>
    <span class="s1">Lexer lexer</span><span class="s5">(</span><span class="s1">code</span><span class="s5">);</span>
    <span class="s5">{</span>
        <span class="s1">Token token </span><span class="s5">= </span><span class="s1">lexer</span><span class="s5">.</span><span class="s1">next_token</span><span class="s5">();</span>
        <span class="s4">while </span><span class="s5">(</span><span class="s1">token</span><span class="s5">.</span><span class="s1">id </span><span class="s5">!= </span><span class="s1">TOK_EOF</span><span class="s5">) {</span>
            <span class="s1">std::cout </span><span class="s5">&lt;&lt; </span><span class="s1">token</span><span class="s5">.</span><span class="s1">to_string</span><span class="s5">() &lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
            <span class="s1">token </span><span class="s5">= </span><span class="s1">lexer</span><span class="s5">.</span><span class="s1">next_token</span><span class="s5">();</span>
        <span class="s5">}</span>
    <span class="s5">}</span>

    <span class="s3">// Reinicializa o lexer para o parser (pois o lexer já foi consumido acima)</span>
    <span class="s1">Lexer lexer2</span><span class="s5">(</span><span class="s1">code</span><span class="s5">);</span>
    <span class="s1">Parser parser</span><span class="s5">(</span><span class="s1">lexer2</span><span class="s5">);</span>

    <span class="s4">try </span><span class="s5">{</span>
        <span class="s1">parser</span><span class="s5">.</span><span class="s1">parse</span><span class="s5">();</span>
        <span class="s1">std::cout </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Parsing, análise semântica e geração de código concluídos com sucesso!</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
    <span class="s5">} </span><span class="s4">catch </span><span class="s5">(</span><span class="s4">const </span><span class="s1">std::exception </span><span class="s5">&amp;</span><span class="s1">e</span><span class="s5">) {</span>
        <span class="s1">std::cerr </span><span class="s5">&lt;&lt; </span><span class="s2">&quot;Falha: &quot; </span><span class="s5">&lt;&lt; </span><span class="s1">e</span><span class="s5">.</span><span class="s1">what</span><span class="s5">() &lt;&lt; </span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s5">;</span>
        <span class="s4">return </span><span class="s6">1</span><span class="s5">;</span>
    <span class="s5">}</span>

    <span class="s4">return </span><span class="s6">0</span><span class="s5">;</span>
<span class="s5">}</span>
</pre>
</body>
</html>